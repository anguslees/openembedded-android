diff -r d1ad52447673 ChangeLog
--- a/ChangeLog	Wed Apr 14 12:21:30 2010 +0200
+++ b/ChangeLog	Tue Jul 20 16:36:52 2010 +0200
@@ -1,3 +1,261 @@
+2010-07-19  Gary Benson  <gbenson@redhat.com>
+
+	PR icedtea/483
+	* ports/hotspot/src/share/vm/shark/sharkNativeWrapper.cpp
+	(SharkNativeWrapper::initialize): Fix signedness of T_BYTE
+	and T_CHAR results.
+
+2010-07-16  Deepak Bhole <dbhole@redhat.com>
+
+	* patches/icedtea-policy-evaluation.patch: New patch. Fixes policy
+	evaluation to match the proprietary JDK.
+
+2010-07-15  Deepak Bhole <dbhole@redhat.com>
+
+	* patches/openjdk/6678385.patch: New file. Backpatched from jdk7 for 
+	upstream bug#6678385. Fixes rhbz# 551835. Fixes jvm crashes when window is
+	resized.
+
+2010-07-14  Jon VanAlten  <jon.vanalten@redhat.com>
+
+	* patches/icedtea-override-redirect-metacity.patch: Produces the
+	"expected" behavior for full screen applications or other situations
+	where developers wish to present elements that would cover things like
+	panels.  We previously had a version of this patch since changeset 876
+	ebc064e8892d, but dropped it in changeset changeset 1731
+	83619682858e because upstream had rejected as a metacity bug[1].
+	Metacity maintains that this behavior does not break any spec and does
+	not appear likely to change either[2], so we must be the "good guys" and
+	provide the expected behavior.  See discussion[3].
+	[1] http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6514512
+	[2] https://bugzilla.gnome.org/show_bug.cgi?id=405269
+	[3] http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2010-April/008862.html
+	* Makefile.am: Apply icedtea-override-redirect-metacity.patch.
+
+2010-07-13  Mark Wielaard  <mjw@redhat.com>
+
+	Reported by William Cohen <wcohen@redhat.com>
+	* tapset/hotspot.stp.in (object_alloc): size is arg4, not arg3.
+
+2010-07-14  Deepak Bhole <dbhole@redhat.com>
+
+	* plugin/icedteanp/java/sun/applet/PluginMessageConsumer.java: Add a new
+	processedIds list to track which instances have been instantiated.
+	(okToProcess): Register width as priority only after handle is acquired.
+	Process resize messages only after tag and handle are processed.
+	(notifyWorkerIsFree): Add instance id to processedIds list if the worked
+	being free'd is an init worker.
+	(getFreeWorker): Create new normal worked only if worker count is less
+	than MAX_WORKERS - PRIORITY_WORKERS.
+	(dumpWorkerStatus): New method. Useful when debugging -- prints status of
+	all workers.
+	* plugin/icedteanp/java/sun/applet/PluginMessageHandlerWorker.java
+	(toString): New method. Returns the string representation of the worker
+	instance at call time.
+
+2010-07-13  Matthias Klose  <doko@ubuntu.com>
+
+	* acinclude.m4 (IT_CHECK_PLUGIN_DEPENDENCIES): Don't require libxul
+	libraries.
+	(IT_CHECK_XULRUNNER_VERSION): Use pkgconfig --modversion as version.
+
+2010-07-13  Deepak Bhole <dbhole@redhat.com>
+
+	* plugin/icedteanp/IcedTeaJavaRequestProcessor.h: Set timeout to 120
+	seconds (previous commit mistakenly changed it to 10).
+	* plugin/icedteanp/IcedTeaPluginUtils.h: Print debug info only in debug
+	mode.
+
+2010-06-14  Deepak Bhole <dbhole@redhat.com>
+
+	* plugin/icedteanp/IcedTeaJavaRequestProcessor.cc: Use variadic macro
+	for debug message printing.
+	* plugin/icedteanp/IcedTeaJavaRequestProcessor.h: Same.
+	* plugin/icedteanp/IcedTeaNPPlugin.cc: Same.
+	* plugin/icedteanp/IcedTeaPluginRequestProcessor.cc: Same.
+	* plugin/icedteanp/IcedTeaPluginUtils.cc: Same.
+	* plugin/icedteanp/IcedTeaPluginUtils.h: Same.
+	* plugin/icedteanp/IcedTeaScriptablePluginObject.cc: Same.
+
+2010-07-12 Jon VanAlten <jon.vanalten@redhat.com>
+	* pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioDataLine.java
+	* pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioLine.java
+	* pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioSourceDataLine.java
+	* pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioTargetDataLine.java:
+	Eliminate spurious exception throwing from open, close, read, write,
+	drain, and flush calls on closed lines.
+	Use isOpen() API call instead of instance variable where appropriate.
+
+2010-07-08  Man Lung Wong  <mwong@redhat.com>
+
+	* netx/net/sourceforge/jnlp/Parser.java:
+	(getRootNode): Used BufferedInputStream instead of InputStream to
+	have mark and reset method available. Passed the encoding to the
+	constructor of InputStreamReader, such that the stream will now
+	be parsed with the encoding the jnlp file is in.
+	(getEncoding): A new method which checks the first four bytes of input
+	and determines what the files encoding is.
+
+2010-06-24 Omair Majid <omajid@redhat.com>
+
+	* netx/net/sourceforge/jnlp/SecurityDesc.java: Fix comments.
+	* netx/net/sourceforge/jnlp/JNLPClassLoader.java
+	(activateJars): Always call activateNative.
+	(activateNative): Search for native code anywhere in the jar.
+
+2010-06-29  Omair Majid <omajid@redhat.com>
+
+	* netx/net/sourceforge/jnlp/runtime/JNLPClassLoader.java
+	nativeDirectories: New variable. Contains a list of directories that
+	contain native libraries.
+	(getInstance): Tell other classloaders about the native directory.
+	(getNativeDir): Add the new native directory to nativeDirectories.
+	(addNativeDirectory): New function.
+	(getNativeDirectories): New function.
+	(findLibrary): Look in all the native directories for the native library.
+
+2010-06-29  Omair Majid <omajid@redhat.com>
+
+	* netx/net/sourceforge/jnlp/services/XSingleInstanceService.java
+	(startListeningServer): Mark the thread as a daemon so the JVM can
+	shutdown if there are no other non-daemon thread running.
+
+2010-06-29 Omair Majid <omajid@redhat.com>
+
+	* netx/net/sourceforge/jnlp/cache/CacheUtil.java
+	(urlToPath): Call FileUtils.sanitizePath.
+	(fixPath): Moved to...
+	* netx/net/sourceforge/jnlp/util/FileUtils.java
+	(sanitizePath): New function. Moved from CacheUtil.java
+	(sanitizeFileName): Use a blacklisting approach rather than a whitelisting
+	approach: should work better with non ascii filenames.
+
+2010-07-08  Omair Majid  <omajid@redhat.com>
+
+	* plugin/icedteanp/java/sun/applet/PluginAppletViewer.java:
+	(reFrame): Pass the panel to the constructor, dont set it yourself.
+	(PluginAppletViewer): Set the panel to be the passed in object and only
+	then add it to the list of all panels.
+
+2010-07-08  Omair Majid  <omajid@redhat.com>
+
+	PR icedtea/460
+	* plugin/icedteanp/java/netscape/security/ForbiddenTargetException.java:
+	New file. Some applets, for legacy support, expect this class to be
+	present.
+
+2010-06-14 Andrew John Hughes  <ahughes@redhat.com>
+
+	Don't print out the return value of pthread_self
+	which is a pthread_t.  pthread_t is an opaque type
+	and we don't know what it actually is (it varies
+	from system to system; recent versions of Linux
+	use an unsigned long int).
+	* plugin/icedteanp/IcedTeaPluginUtils.h:
+	(PLUGIN_DEBUG_0ARG(str)): Don't print the thread_t.
+	(PLUGIN_DEBUG_1ARG(str,arg1)): Likewise.
+	(PLUGIN_DEBUG_2ARG(str,arg1,arg2)): Likewise.
+	(PLUGIN_DEBUG_3ARG(str,arg1,arg2,arg3)): Likewise.
+	(PLUGIN_DEBUG_4ARG(str,arg1,arg2,arg3,arg4)): Likewise.
+	(PLUGIN_DEBUG_5ARG(str,arg1,arg2,arg3,arg4,arg5)): Likewise.
+
+2010-06-14  Deepak Bhole <dbhole@redhat.com>
+
+	* plugin/icedteanp/java/sun/applet/PluginMessageConsumer.java: Fix bug
+	causing 100% CPU usage (rhbz# 592553).
+
+2010-06-14  Omair Majid <omajid@redhat.com>
+
+	PR icedtea/488
+	* plugin/icedteanp/IcedTeaPluginUtils.h: Bug #488. Fix bug due to
+	incorrect assumption that 'A' > 'a'.
+
+2010-06-14  Omair Majid <omajid@redhat.com>
+
+	PR icedtea/480
+	* plugin/icedteanp/IcedTeaNPPlugin.cc: Use getproperty NPAPI call instead
+	of evaluate, to get page URL.
+
+2010-05-07  Deepak Bhole <dbhole@redhat.com>
+
+	PR icedtea/436:
+	* plugin/icedteanp/java/sun/applet/PluginAppletViewer.java
+	(handleMessage): Don't print stack trace on InterruptedException.
+	(appletClose): Kill misbehaving applets that don't shut down properly.
+
+2010-05-07  Deepak Bhole <dbhole@redhat.com>
+
+	* netx/net/sourceforge/jnlp/Launcher.java
+	(setContextClassLoaderForAllThreads): Change to set context CL only for
+	given threadgroup.
+	(launchApplication): Supply threadgroup to
+	setContextClassLoaderForAllThreads.
+	(createApplet): Same.
+
+2010-05-07  Gary Benson  <gbenson@redhat.com>
+
+	* netx/net/sourceforge/jnlp/runtime/JNLPSecurityManager.java:
+	Removed a stray semicolon.
+
+2010-05-06  Deepak Bhole <dbhole@redhat.com>
+
+	* netx/net/sourceforge/jnlp/runtime/JNLPSecurityManager.java:
+	Add imports missed in last commit.
+
+2010-05-06  Deepak Bhole <dbhole@redhat.com>
+
+	* rt/net/sourceforge/jnlp/runtime/JNLPSecurityManager.java
+	(checkPermission): Allow Runtime and Security permission (for
+	putProvider.SunJCE) if initiated for an https connection.
+	(inTrustedCallChain): New method. Returns if given class/method is
+	in the call chain, and everything upto there is trusted.
+
+2010-05-05  Gary Benson  <gbenson@redhat.com>
+
+	PR icedtea/481
+	* ports/hotspot/src/share/vm/shark/sharkTopLevelBlock.cpp
+	(SharkTopLevelBlock::improve_virtual_call): Disable an
+	optimization that cannot currently be supported.
+
+2010-04-30  Gary Benson  <gbenson@redhat.com>
+
+	PR icedtea/324
+	* ports/hotspot/src/share/vm/shark/sharkTopLevelBlock.cpp
+	(SharkTopLevelBlock::do_aload): Cope with cases where
+	the array's type is unknown.
+	(SharkTopLevelBlock::do_astore): Likewise.
+
+2010-04-28  Andrew John Hughes  <ahughes@redhat.com>
+
+	PR icedtea/476
+	* Makefile.am:
+	Add patch when SystemTap is enabled to support
+	building with GCC 4.5.
+	* patches/systemtap-gcc-4.5.patch:
+	Add cast to NULL (doesn't apply to DTrace due
+	to differences between SystemTap and DTrace macros).
+
+2010-04-24  Matthias Klose  <doko@ubuntu.com>
+
+	* Makefile.am (check-langtools, check-jdk): Allow overwriting -samevm
+	with the environment variable ICEDTEA_JTREG_OTHERVM.
+
+2010-04-22  Xerxes RÃ¥nby  <xerxes@zafena.se>
+
+	* ports/hotspot/src/share/vm/shark/sharkNativeWrapper.cpp
+	(SharkNativeWrapper::initialize): Shark calling static jni
+	methods jclass argument fix.
+
+2010-04-04  Nobuhiro Iwamatsu <iwamatsu@nigauri.org>
+
+	* acinclude.m4 (IT_SET_ARCH_SETTINGS): Fix Hitachi SH settings.
+
+2010-04-21  Deepak Bhole <dbhole@redhat.com>
+
+	* plugin/icedteanp/IcedTeaNPPlugin.cc
+	(plugin_filter_environment): Increment malloc size by one to account for
+	NULL terminator. Bug# 474.
+
 2010-04-12  Andrew John Hughes  <ahughes@redhat.com>
 
 	PR icedtea/373
diff -r d1ad52447673 Makefile.am
--- a/Makefile.am	Wed Apr 14 12:21:30 2010 +0200
+++ b/Makefile.am	Tue Jul 20 16:36:52 2010 +0200
@@ -298,6 +298,7 @@
 	patches/icedtea-linux-separate-debuginfo.patch \
 	patches/icedtea-parisc.patch \
 	patches/icedtea-sh4-support.patch \
+	patches/icedtea-policy-evaluation.patch \
 	patches/libpng.patch \
 	patches/extensions/netx.patch \
 	patches/extensions/netx-dist.patch \
@@ -326,7 +327,9 @@
 	patches/security/20100330/6932480.patch \
 	patches/ant-1.8.0.patch \
 	patches/icedtea-nss-6763530.patch \
-	patches/nss-debug.patch
+	patches/nss-debug.patch \
+	patches/icedtea-override-redirect-metacity.patch \
+	patches/openjdk/6678385.patch
 
 if WITH_RHINO
 ICEDTEA_PATCHES += \
@@ -374,7 +377,8 @@
 endif
 
 if ENABLE_SYSTEMTAP
-ICEDTEA_PATCHES += patches/icedtea-systemtap.patch
+ICEDTEA_PATCHES += patches/icedtea-systemtap.patch \
+	patches/systemtap-gcc-4.5.patch
 endif
 
 if ENABLE_NSS
@@ -2024,7 +2028,8 @@
 	mkdir -p test/langtools/JTwork test/langtools/JTreport
 	$(ICEDTEA_BOOT_DIR)/bin/java -jar test/jtreg.jar -v1 -a -ignore:quiet \
 		-w:test/langtools/JTwork -r:test/langtools/JTreport \
-		-s -jdk:`pwd`/$(BUILD_OUTPUT_DIR)/j2sdk-image \
+		$${ICEDTEA_JTREG_OTHERVM:--samevm} \
+		-jdk:`pwd`/$(BUILD_OUTPUT_DIR)/j2sdk-image \
 		$(ICEDTEA_JTREG_OPTIONS) \
 		`pwd`/openjdk/langtools/test \
 	    | tee test/$@.log
@@ -2033,7 +2038,8 @@
 	mkdir -p test/jdk/JTwork test/jdk/JTreport
 	$(ICEDTEA_BOOT_DIR)/bin/java -jar test/jtreg.jar -v1 -a -ignore:quiet \
 		-w:test/jdk/JTwork -r:test/jdk/JTreport \
-		-s -jdk:`pwd`/$(BUILD_OUTPUT_DIR)/j2sdk-image \
+		$${ICEDTEA_JTREG_OTHERVM:--samevm} \
+		-jdk:`pwd`/$(BUILD_OUTPUT_DIR)/j2sdk-image \
 		-exclude:$(abs_top_srcdir)/test/jtreg/excludelist.jdk.jtx \
 		$(ICEDTEA_JTREG_OPTIONS) \
 		`pwd`/openjdk/jdk/test \
diff -r d1ad52447673 acinclude.m4
--- a/acinclude.m4	Wed Apr 14 12:21:30 2010 +0200
+++ b/acinclude.m4	Tue Jul 20 16:36:52 2010 +0200
@@ -85,7 +85,7 @@
       CROSS_TARGET_ARCH=s390x
       ARCHFLAG="-m64"
        ;;
-    sh*-*-*)
+    sh*)
       BUILD_ARCH_DIR=sh
       INSTALL_ARCH_DIR=sh
       JRE_ARCH_DIR=sh
@@ -1461,15 +1461,7 @@
   AC_SUBST(GTK_CFLAGS)
   AC_SUBST(GTK_LIBS)
 
-
-  if $PKG_CONFIG --atleast-version 1.9.2 libxul 2>&AS_MESSAGE_LOG_FD ; then
-    xullibs=libxul
-  else
-    xullibs="libxul libxul-unstable"
-  fi
-
-  PKG_CHECK_MODULES(MOZILLA, \
-    mozilla-plugin ${xullibs})
+  PKG_CHECK_MODULES(MOZILLA, mozilla-plugin)
     
   AC_SUBST(MOZILLA_CFLAGS)
   AC_SUBST(MOZILLA_LIBS)
@@ -1482,52 +1474,13 @@
 AC_REQUIRE([IT_CHECK_PLUGIN_DEPENDENCIES])
 if test "x${enable_plugin}" = "xyes"
 then
-  AC_LANG_PUSH([C++])
-  OLDCPPFLAGS="$CPPFLAGS"
-  CPPFLAGS="$CPPFLAGS $MOZILLA_CFLAGS"
-
-  AC_CACHE_CHECK([for xulrunner version], [xulrunner_cv_collapsed_version],
-      [AC_RUN_IFELSE(
-        [AC_LANG_PROGRAM([[
-#include <mozilla-config.h>
-#include <math.h>
-#include <string.h>
-#include <stdlib.h>
-#include <stdio.h>
-]],[[
-int version = 0;
-const char* token = NULL;
-int power=6;
-FILE *datafile;
-
-datafile = fopen ("conftest.vdata", "w");
-if (!datafile) return 1;
-
-// 32 chars is more than enough to hold version
-char* mozilla_version = (char*) malloc(32*sizeof(char));
-snprintf(mozilla_version, 32, "%s", MOZILLA_VERSION);
-
-token = strtok(mozilla_version, ".");
-while (token)
-{
-    version += atoi(token)*(pow(10, power));
-    power -=2;
-    token = strtok(NULL, ".");
-}
-
-fprintf (datafile, "%d\n", version);
-free(mozilla_version);
-if (fclose(datafile)) return 1;
-
-return EXIT_SUCCESS;
-]])],
-    [xulrunner_cv_collapsed_version="$(cat conftest.vdata)"],
-    [AC_MSG_FAILURE([cannot determine xulrunner version])])],
-  [xulrunner_cv_collapsed_version="190000"])
-
-  CPPFLAGS="$OLDCPPFLAGS"
-  AC_LANG_POP([C++])
-
+  AC_CACHE_CHECK([for xulrunner version], [xulrunner_cv_collapsed_version],[
+    if pkg-config --modversion libxul >/dev/null 2>&1
+    then
+      xulrunner_cv_collapsed_version=`pkg-config --modversion libxul | awk -F. '{power=6; v=0; for (i=1; i <= NF; i++) {v += $i * 10 ^ power; power -=2}; print v}'`
+    else
+      AC_MSG_FAILURE([cannot determine xulrunner version])
+    fi])
   AC_SUBST(MOZILLA_VERSION_COLLAPSED, $xulrunner_cv_collapsed_version)
 fi
 ])
diff -r d1ad52447673 netx/net/sourceforge/jnlp/Launcher.java
--- a/netx/net/sourceforge/jnlp/Launcher.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/netx/net/sourceforge/jnlp/Launcher.java	Tue Jul 20 16:36:52 2010 +0200
@@ -442,7 +442,7 @@
             Method main = mainClass.getDeclaredMethod("main", new Class[] {String[].class} );
             String args[] = file.getApplication().getArguments();
 
-            setContextClassLoaderForAllThreads(app.getClassLoader());
+            setContextClassLoaderForAllThreads(app.getThreadGroup(), app.getClassLoader());
 
             if (splashScreen != null) {
                 if (splashScreen.isSplashScreenValid()) {
@@ -464,30 +464,24 @@
     }
 
     /**
-     * Set the classloader as the context classloader for all threads. This is
-     * required to make some applications work. For example, an application that
-     * provides a custom Swing LnF may ask the swing thread to load resources
-     * from their JNLP, which would only work if the Swing thread knows about
-     * the JNLPClassLoader.
+     * Set the classloader as the context classloader for all threads in 
+     * the given threadgroup. This is required to make some applications 
+     * work. For example, an application that provides a custom Swing LnF 
+     * may ask the swing thread to load resources from their JNLP, which 
+     * would only work if the Swing thread knows about the JNLPClassLoader.
      * 
+     * @param tg The threadgroup for which the context classloader should be set
      * @param classLoader the classloader to set as the context classloader
      */
-    private void setContextClassLoaderForAllThreads(ClassLoader classLoader) {
-        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
-        ThreadGroup root;
-        
-        root = Thread.currentThread().getThreadGroup();
-        while (root.getParent() != null) {
-            root = root.getParent();
-        }
+    private void setContextClassLoaderForAllThreads(ThreadGroup tg, ClassLoader classLoader) {
 
         /* be prepared for change in thread size */
-        int threadCountGuess = threadBean.getThreadCount();
+        int threadCountGuess = tg.activeCount();
         Thread[] threads;
         do {
             threadCountGuess = threadCountGuess * 2;
             threads = new Thread[threadCountGuess];
-            root.enumerate(threads, true);
+            tg.enumerate(threads, true);
         } while (threads[threadCountGuess-1] != null);
         
         
@@ -595,7 +589,7 @@
             group.setApplication(appletInstance);
             loader.setApplication(appletInstance);
 
-            setContextClassLoaderForAllThreads(appletInstance.getClassLoader());
+            setContextClassLoaderForAllThreads(appletInstance.getThreadGroup(), appletInstance.getClassLoader());
 
             return appletInstance;
         }
diff -r d1ad52447673 netx/net/sourceforge/jnlp/Parser.java
--- a/netx/net/sourceforge/jnlp/Parser.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/netx/net/sourceforge/jnlp/Parser.java	Tue Jul 20 16:36:52 2010 +0200
@@ -1169,11 +1169,15 @@
             Node jnlpNode = getChildNode(document, "jnlp"); // skip comments
             */
 
+            //A BufferedInputStream is used to allow marking and reseting 
+            //of a stream.    
+            BufferedInputStream bs = new BufferedInputStream(input);
+
             /* NANO */
             final XMLElement xml = new XMLElement();
             final PipedInputStream pin = new PipedInputStream();
             final PipedOutputStream pout = new PipedOutputStream(pin);
-            final InputStreamReader isr = new InputStreamReader(input);    
+            final InputStreamReader isr = new InputStreamReader(bs, getEncoding(bs));
             // Clean the jnlp xml file of all comments before passing
             // it to the parser.
             new Thread(
@@ -1196,7 +1200,69 @@
             throw new ParseException(R("PBadXML"), ex);
         }
     }
+    
+    /**
+     * Returns the name of the encoding used in this InputStream.
+     *
+     * @param input the InputStream
+     * @return a String representation of encoding
+     */
+    private static String getEncoding(InputStream input) throws IOException{
+        //Fixme: This only recognizes UTF-8, UTF-16, and 
+        //UTF-32, which is enough to parse the prolog portion of xml to
+        //find out the exact encoding (if it exists). The reason being
+        //there could be other encodings, such as ISO 8859 which is 8-bits
+        //but it supports latin characters.  
+        //So what needs to be done is to parse the prolog and retrieve
+        //the exact encoding from it.
 
+        int[] s = new int[4];
+        String encoding = "UTF-8";
+
+        //Determine what the first four bytes are and store 
+        //them into an int array.
+        input.mark(4);
+        for (int i = 0; i < 4; i++) {
+            s[i] = input.read(); 
+        }
+        input.reset();
+
+        //Set the encoding base on what the first four bytes of the
+        //inputstream turn out to be (following the information from
+        //www.w3.org/TR/REC-xml/#sec-guessing).
+        if (s[0] == 255) {
+            if (s[1] == 254) {
+                if (s[2] != 0 || s[3] != 0) {
+                    encoding = "UnicodeLittle";
+                } else {
+                    encoding = "X-UTF-32LE-BOM";
+                }
+            }
+        } else if (s[0] == 254 && s[1] == 255 && (s[2] != 0 || 
+          s[3] != 0)) {
+            encoding = "UTF-16";
+
+        } else if (s[0] == 0 && s[1] == 0 && s[2] == 254 && 
+          s[3] == 255) {
+            encoding = "X-UTF-32BE-BOM";
+
+        } else if (s[0] == 0 && s[1] == 0 && s[2] == 0 && 
+          s[3] == 60) {
+            encoding = "UTF-32BE";
+ 
+        } else if (s[0] == 60 && s[1] == 0 && s[2] == 0 && 
+          s[3] == 0) {
+            encoding = "UTF-32LE";
+
+        } else if (s[0] == 0 && s[1] == 60 && s[2] == 0 && 
+          s[3] == 63) { 
+            encoding = "UTF-16BE"; 
+        } else if (s[0] == 60 && s[1] == 0 && s[2] == 63 &&
+          s[3] == 0) { 
+            encoding = "UTF-16LE";
+        }
+
+        return encoding;
+    }
 }
 
-
diff -r d1ad52447673 netx/net/sourceforge/jnlp/SecurityDesc.java
--- a/netx/net/sourceforge/jnlp/SecurityDesc.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/netx/net/sourceforge/jnlp/SecurityDesc.java	Tue Jul 20 16:36:52 2010 +0200
@@ -31,12 +31,9 @@
  */
 public class SecurityDesc {
 
-    // todo: make sure classloader's native code support checks
-    // the security permissions
-
-    // shouldn't need to verify that native code only runs in
-    // trusted environment because the parser and/or classloader
-    // should kick it.
+    /*
+     * We do not verify security here, the classloader deals with security
+     */
 
     /** All permissions. */
     public static final Object ALL_PERMISSIONS = "All";
diff -r d1ad52447673 netx/net/sourceforge/jnlp/cache/CacheUtil.java
--- a/netx/net/sourceforge/jnlp/cache/CacheUtil.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/netx/net/sourceforge/jnlp/cache/CacheUtil.java	Tue Jul 20 16:36:52 2010 +0200
@@ -26,6 +26,7 @@
 
 import net.sourceforge.jnlp.*;
 import net.sourceforge.jnlp.runtime.*;
+import net.sourceforge.jnlp.util.FileUtils;
 
 /**
  * Provides static methods to interact with the cache, download
@@ -300,23 +301,9 @@
         path.append(File.separatorChar);
         path.append(location.getPath().replace('/', File.separatorChar));
 
-        return new File(JNLPRuntime.getBaseDir(), fixPath(path.toString()));
+        return new File(JNLPRuntime.getBaseDir(), FileUtils.sanitizePath(path.toString()));
     }
 
-    /**
-     * Clean up a string by removing characters that can't appear in
-     * a local file name.
-     */
-    private static String fixPath(String path) {
-        char badChars[] = { '\\', '/', ':', '*', '?', '"', '<', '>', '|' };
-
-        for (int i=0; i < badChars.length; i++)
-            if (badChars[i] != File.separatorChar)
-                if (-1 != path.indexOf(badChars[i]))
-                    path = path.replace(badChars[i], 'X');
-
-        return path;
-    }
 
     /**
      * Waits until the resources are downloaded, while showing a
diff -r d1ad52447673 netx/net/sourceforge/jnlp/runtime/JNLPClassLoader.java
--- a/netx/net/sourceforge/jnlp/runtime/JNLPClassLoader.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/netx/net/sourceforge/jnlp/runtime/JNLPClassLoader.java	Tue Jul 20 16:36:52 2010 +0200
@@ -32,6 +32,7 @@
 import java.security.Permissions;
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.LinkedList;
@@ -80,12 +81,12 @@
     /** map from JNLPFile url to shared classloader */
     private static Map urlToLoader = new HashMap(); // never garbage collected!
 
-    /** number of times a classloader with native code is created */
-    private static int nativeCounter = 0;
-
     /** the directory for native code */
     private File nativeDir = null; // if set, some native code exists
 
+    /** a list of directories that contain native libraries */
+    private List<File> nativeDirectories = Collections.synchronizedList(new LinkedList<File>());
+
     /** security context */
     private AccessControlContext acc = AccessController.getContext();
 
@@ -240,18 +241,22 @@
 		        // loader for this unique key. Check.
 		        JNLPClassLoader extLoader = (JNLPClassLoader) urlToLoader.get(uniqueKey);
 
-		        if (extLoader != null) {
+		        if (extLoader != null && extLoader != loader) {
 		            for (URL u : loader.getURLs())
 		                extLoader.addURL(u);
+		            for (File nativeDirectory: loader.getNativeDirectories())
+		                extLoader.addNativeDirectory(nativeDirectory);
 
 		            loader = extLoader;
 		        }
 
                 // loader is now current + ext. But we also need to think of 
                 // the baseLoader
-		        if (baseLoader != null) {
+		        if (baseLoader != null && baseLoader != loader) {
                     for (URL u : loader.getURLs())
                         baseLoader.addURL(u);
+                    for (File nativeDirectory: loader.getNativeDirectories())
+                        baseLoader.addNativeDirectory(nativeDirectory);
 
                     loader = baseLoader;
                 } 
@@ -642,8 +647,8 @@
                             ex.printStackTrace();
                     }
 
-                    if (jar.isNative())
-                        activateNative(jar);
+                    // some programs place a native library in any jar
+                    activateNative(jar);
                 }
 
                 return null;
@@ -654,9 +659,9 @@
     }
 
     /**
-     * Enable the native code contained in a JAR by copying the
-     * native files into the filesystem.  Called in the security
-     * context of the classloader.
+     * Search for and enable any native code contained in a JAR by copying the
+     * native files into the filesystem. Called in the security context of the
+     * classloader.
      */
     protected void activateNative(JARDesc jar) {
         if (JNLPRuntime.isDebug())
@@ -669,17 +674,33 @@
         if (nativeDir == null)
             nativeDir = getNativeDir();
 
+        String[] librarySuffixes = { ".so", ".dylib", ".jnilib", ".framework", ".dll" };
+
         try {
             JarFile jarFile = new JarFile(localFile, false);
-            Enumeration entries = jarFile.entries();
+            Enumeration<JarEntry> entries = jarFile.entries();
 
             while (entries.hasMoreElements()) {
-                JarEntry e = (JarEntry) entries.nextElement();
+                JarEntry e = entries.nextElement();
 
-                if (e.isDirectory() || e.getName().indexOf('/') != -1)
+                if (e.isDirectory()) {
                     continue;
+                }
 
-                File outFile = new File(nativeDir, e.getName());
+                String name = new File(e.getName()).getName();
+                boolean isLibrary = false;
+
+                for (String suffix: librarySuffixes) {
+                    if (name.endsWith(suffix)) {
+                       isLibrary = true;
+                       break;
+                    }
+                }
+                if (!isLibrary) {
+                    continue;
+                }
+
+                File outFile = new File(nativeDir, name);
 
                 CacheUtil.streamCopy(jarFile.getInputStream(e),
                                      new FileOutputStream(outFile));
@@ -703,29 +724,47 @@
 
         if (!nativeDir.mkdirs()) 
             return null;
-        else
+        else {
+            // add this new native directory to the search path
+            addNativeDirectory(nativeDir);
             return nativeDir;
+        }
+    }
+
+    /**
+     * Adds the {@link File} to the search path of this {@link JNLPClassLoader}
+     * when trying to find a native library
+     */
+    protected void addNativeDirectory(File nativeDirectory) {
+        nativeDirectories.add(nativeDirectory);
+    }
+
+    /**
+     * Returns a list of all directories in the search path of the current classloader
+     * when it tires to find a native library.
+     * @return a list of directories in the search path for native libraries
+     */
+    protected List<File> getNativeDirectories() {
+        return nativeDirectories;
     }
 
     /**
      * Return the absolute path to the native library.
      */
     protected String findLibrary(String lib) {
-        if (nativeDir == null)
-            return null;
-
         String syslib = System.mapLibraryName(lib);
 
-        File target = new File(nativeDir, syslib);
-        if (target.exists())
-            return target.toString();
-        else {
-            String result = super.findLibrary(lib);
-            if (result != null)
-                return result;
+        for (File dir: getNativeDirectories()) {
+            File target = new File(dir, syslib);
+            if (target.exists())
+                return target.toString();
+        }
 
-            return findLibraryExt(lib);
-        }
+        String result = super.findLibrary(lib);
+        if (result != null)
+            return result;
+
+        return findLibraryExt(lib);
     }
 
     /**
diff -r d1ad52447673 netx/net/sourceforge/jnlp/runtime/JNLPSecurityManager.java
--- a/netx/net/sourceforge/jnlp/runtime/JNLPSecurityManager.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/netx/net/sourceforge/jnlp/runtime/JNLPSecurityManager.java	Tue Jul 20 16:36:52 2010 +0200
@@ -23,10 +23,12 @@
 import java.awt.event.WindowEvent;
 import java.lang.ref.WeakReference;
 import java.net.SocketPermission;
+import java.security.AllPermission;
 import java.security.AccessControlException;
 import java.security.AccessController;
 import java.security.Permission;
 import java.security.PrivilegedAction;
+import java.security.SecurityPermission;
 import java.util.PropertyPermission;
 
 import javax.swing.JWindow;
@@ -395,6 +397,24 @@
 				    // Everything else is denied
 				    throw se;
 
+				} else if (perm instanceof SecurityPermission) {
+
+				    // JCE's initialization requires putProviderProperty permission
+				    if (perm.equals(new SecurityPermission("putProviderProperty.SunJCE"))) {
+				        if (inTrustedCallChain("com.sun.crypto.provider.SunJCE", "run")) {
+				            return;
+				        }
+				    }
+
+				} else if (perm instanceof RuntimePermission) {
+
+				    // KeyGenerator's init method requires internal spec access
+				    if (perm.equals(new SecurityPermission("accessClassInPackage.sun.security.internal.spec"))) {
+				        if (inTrustedCallChain("javax.crypto.KeyGenerator", "init")) {
+				            return;
+				        }
+				    }
+
 				} else {
 				    tmpPerm = perm;
 				}
@@ -419,6 +439,34 @@
         }
     }
 
+    /** 
+     * Returns weather the given class and method are in the current stack, 
+     * and whether or not everything upto then is trusted
+     * 
+     * @param className The name of the class to look for in the stack
+     * @param methodName The name of the method for the given class to look for in the stack
+     * @return Weather or not class::method() are in the chain, and everything upto there is trusted
+     */
+    private boolean inTrustedCallChain(String className, String methodName) {
+        
+        StackTraceElement[] stack =  Thread.currentThread().getStackTrace();
+        
+        for (int i=0; i < stack.length; i++) {
+
+            // Everything up to the desired class/method must be trusted
+            if (!stack[i].getClass().getProtectionDomain().implies(new AllPermission())) {
+                return false;
+            }
+
+            if (stack[i].getClassName().equals(className) &&
+                stack[i].getMethodName().equals(methodName)) {
+                return true;
+            }
+        }
+        
+        return false;
+    }
+    
     /**
      * Asks the user whether or not to grant permission.
      * @param perm the permission to be granted
diff -r d1ad52447673 netx/net/sourceforge/jnlp/services/XSingleInstanceService.java
--- a/netx/net/sourceforge/jnlp/services/XSingleInstanceService.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/netx/net/sourceforge/jnlp/services/XSingleInstanceService.java	Tue Jul 20 16:36:52 2010 +0200
@@ -145,14 +145,21 @@
     }
 
     /**
-     * Start the listening server to accept arguments from new isntances of
+     * Start the listening server to accept arguments from new instances of
      * applications
      * 
      * @param lockFile
+     *            the {@link SingleInstanceLock} that the server should use
      */
     private void startListeningServer(SingleInstanceLock lockFile) {
         SingleInstanceServer server = new SingleInstanceServer(lockFile);
-        new Thread(server).start();
+        Thread serverThread = new Thread(server);
+        /* 
+         * mark as daemon so the JVM can shutdown if the server is the only
+         * thread running
+         */
+        serverThread.setDaemon(true);
+        serverThread.start();
     }
 
     /**
diff -r d1ad52447673 netx/net/sourceforge/jnlp/util/FileUtils.java
--- a/netx/net/sourceforge/jnlp/util/FileUtils.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/netx/net/sourceforge/jnlp/util/FileUtils.java	Tue Jul 20 16:36:52 2010 +0200
@@ -14,35 +14,58 @@
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-
 package net.sourceforge.jnlp.util;
 
+import java.io.File;
+
 /**
- * This class contains a few file-related utility functions. 
+ * This class contains a few file-related utility functions.
  * 
  * @author Omair Majid
  */
 
-public class FileUtils {
+public final class FileUtils {
 
-    
+    /**
+     * list of characters not allowed in filenames
+     */
+    private static final char INVALID_CHARS[] = { '\\', '/', ':', '*', '?', '"', '<', '>', '|' };
+
+    private static final char SANITIZED_CHAR = '_';
+
+    /**
+     * Clean up a string by removing characters that can't appear in a local
+     * file name.
+     *
+     * @param path
+     *        the path to sanitize
+     * @return a sanitized version of the input which is suitable for using as a
+     *         file path
+     */
+    public static String sanitizePath(String path) {
+
+        for (int i = 0; i < INVALID_CHARS.length; i++)
+            if (INVALID_CHARS[i] != File.separatorChar)
+                if (-1 != path.indexOf(INVALID_CHARS[i]))
+                    path = path.replace(INVALID_CHARS[i], SANITIZED_CHAR);
+
+        return path;
+    }
+
     /**
      * Given an input, return a sanitized form of the input suitable for use as
      * a file/directory name
-     * 
+     *
      * @param input
      * @return a sanitized version of the input
      */
-    public static String sanitizeFileName(String input) {
+    public static String sanitizeFileName(String filename) {
 
-        /*
-         * FIXME
-         * 
-         * Assuming safe characters are 'a-z','A-Z','0-9', '_', '.'
-         */
+        for (int i = 0; i < INVALID_CHARS.length; i++)
+            if (-1 != filename.indexOf(INVALID_CHARS[i]))
+                filename = filename.replace(INVALID_CHARS[i], SANITIZED_CHAR);
 
-        String sanitizedName = input.replaceAll("[^a-zA-Z0-9.]", "_");
-        return sanitizedName;
+        return filename;
     }
-    
+
 }
diff -r d1ad52447673 patches/icedtea-override-redirect-metacity.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/patches/icedtea-override-redirect-metacity.patch	Tue Jul 20 16:36:52 2010 +0200
@@ -0,0 +1,11 @@
+--- openjdk/jdk/src/solaris/classes/sun/awt/X11/XWindowPeer.java.orig	2008-05-25 17:31:31.000000000 +0200
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XWindowPeer.java	2008-05-25 17:33:32.000000000 +0200
+@@ -1124,6 +1124,8 @@
+ 
+     boolean isOverrideRedirect() {
+         return (XWM.getWMID() == XWM.OPENLOOK_WM ? true : false) ||
++            (XWM.getWMID() == XWM.METACITY_WM ? true : false) ||
++            target.getName().equals("###overrideRedirect###") ||
+             ((XToolkit)Toolkit.getDefaultToolkit()).isOverrideRedirect((Window)target) ||
+             XTrayIconPeer.isTrayIconStuffWindow((Window)target);
+     }
diff -r d1ad52447673 patches/icedtea-policy-evaluation.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/patches/icedtea-policy-evaluation.patch	Tue Jul 20 16:36:52 2010 +0200
@@ -0,0 +1,35 @@
+# This patch aligns policy evaluation to be the same as the proprietary JDK.
+# http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2010-July/009658.html
+# https://bugs.openjdk.java.net/show_bug.cgi?id=100142
+
+diff -up ./openjdk/jdk/src/share/classes/sun/security/provider/PolicyFile.java.sav ./jdk/src/share/classes/sun/security/provider/PolicyFile.java
+--- ./openjdk.orig/jdk/src/share/classes/sun/security/provider/PolicyFile.java.sav	2010-04-20 14:49:13.000000000 -0400
++++ ./openjdk/jdk/src/share/classes/sun/security/provider/PolicyFile.java	2010-04-20 14:50:26.000000000 -0400
+@@ -1799,6 +1799,27 @@ public class PolicyFile extends java.sec
+ 
+         CodeSource canonCs = cs;
+         URL u = cs.getLocation();
++        
++        // If this is a jar protocol url, collapse it to a 
++        // file protocol to process it as per the javadocs
++        if (u != null && u.getProtocol().equals("jar")) {
++            try {
++                String fileURL = "";
++            
++                // remove the initial jar:
++                fileURL = u.getPath();
++            
++                // remove the part after the !
++                fileURL = fileURL.substring(0, fileURL.indexOf('!'));
++                
++                u = new URL(fileURL);
++
++            } catch (Exception e) {
++                // Fail silently. In this case, url stays what it was above
++            }
++            
++        }
++        
+         if (u != null && u.getProtocol().equals("file")) {
+             boolean isLocalFile = false;
+             String host = u.getHost();
diff -r d1ad52447673 patches/openjdk/6678385.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/patches/openjdk/6678385.patch	Tue Jul 20 16:36:52 2010 +0200
@@ -0,0 +1,1241 @@
+# HG changeset patch
+# User art
+# Date 1242387635 -14400
+# Node ID f62f7fcc9965cd0b110f07b4cd42c419f77717c1
+# Parent  b28b073e72b625a4d8b6e71010a2968b5fc85124
+6678385: Random java.lang.StackOverflowError from various JDKs
+Reviewed-by: stayer
+
+IcedTea6 note: This patch (upstream bz#6678385) fixes rhbz# 551835.
+
+diff -uNr openjdk.orig/jdk/make/sun/xawt/mapfile-vers openjdk/jdk/make/sun/xawt/mapfile-vers
+--- openjdk.orig/jdk/make/sun/xawt/mapfile-vers	2010-07-15 10:28:21.755105655 -0400
++++ openjdk/jdk/make/sun/xawt/mapfile-vers	2010-07-15 10:28:42.630981569 -0400
+@@ -125,6 +125,7 @@
+         Java_sun_awt_X11_XlibWrapper_SetToolkitErrorHandler;
+         Java_sun_awt_X11_XlibWrapper_XSetErrorHandler;
+         Java_sun_awt_X11_XlibWrapper_CallErrorHandler;
++        Java_sun_awt_X11_XlibWrapper_PrintXErrorEvent;
+         Java_sun_awt_X11_XlibWrapper_XInternAtoms;
+         Java_sun_awt_X11_XlibWrapper_XChangeWindowAttributes;
+         Java_sun_awt_X11_XlibWrapper_XDeleteProperty;
+@@ -269,7 +270,6 @@
+         Java_sun_awt_X11_XToolkit_getDefaultXColormap;
+         Java_sun_awt_X11_XToolkit_getDefaultScreenData;
+         Java_sun_awt_X11_XToolkit_getEnv;
+-        Java_sun_awt_X11_XToolkit_setNoisyXErrorHandler;
+         Java_sun_awt_X11_XlibWrapper_XCreateBitmapFromData;
+         Java_sun_awt_X11_XlibWrapper_XFreePixmap;
+         Java_sun_awt_X11_XlibWrapper_XAllocColor;
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/MotifDnDConstants.java openjdk/jdk/src/solaris/classes/sun/awt/X11/MotifDnDConstants.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/MotifDnDConstants.java	2010-07-15 10:28:21.905105617 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/MotifDnDConstants.java	2010-07-15 10:28:42.631981678 -0400
+@@ -119,7 +119,7 @@
+                                                             false,
+                                                             XlibWrapper.AnyPropertyType);
+         try {
+-            int status = wpg.execute(XToolkit.IgnoreBadWindowHandler);
++            int status = wpg.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+             if (status == XlibWrapper.Success &&
+                 wpg.getData() != 0 &&
+@@ -189,7 +189,7 @@
+                 try {
+                     Native.putLong(data, motifWindow);
+ 
+-                    XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++                    XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+                     XlibWrapper.XChangeProperty(XToolkit.getDisplay(),
+                                                 defaultRootWindow,
+                                                 XA_MOTIF_DRAG_WINDOW.getAtom(),
+@@ -276,7 +276,7 @@
+                                                             false,
+                                                             XA_MOTIF_DRAG_TARGETS.getAtom());
+         try {
+-            int status = wpg.execute(XToolkit.IgnoreBadWindowHandler);
++            int status = wpg.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+             if (status != XlibWrapper.Success
+                 || wpg.getActualType() != XA_MOTIF_DRAG_TARGETS.getAtom()
+@@ -390,7 +390,7 @@
+                 }
+             }
+ 
+-            XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+             XlibWrapper.XChangeProperty(XToolkit.getDisplay(),
+                                         motifWindow,
+                                         XA_MOTIF_DRAG_TARGETS.getAtom(),
+@@ -406,7 +406,7 @@
+                 // Create a new motif window and retry.
+                 motifWindow = createMotifWindow();
+ 
+-                XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+                 XlibWrapper.XChangeProperty(XToolkit.getDisplay(),
+                                             motifWindow,
+                                             XA_MOTIF_DRAG_TARGETS.getAtom(),
+@@ -530,7 +530,7 @@
+             // CARD32 icc_handle
+             unsafe.putInt(structData + 4, (int)XA_MOTIF_ATOM_0.getAtom());
+ 
+-            XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+             XlibWrapper.XChangeProperty(XToolkit.getDisplay(), window,
+                                         XA_MOTIF_ATOM_0.getAtom(),
+                                         XA_MOTIF_DRAG_INITIATOR_INFO.getAtom(),
+@@ -563,7 +563,7 @@
+             unsafe.putShort(data + 10, (short)0); /* pad */
+             unsafe.putInt(data + 12, dataSize);
+ 
+-            XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+             XlibWrapper.XChangeProperty(XToolkit.getDisplay(), window,
+                                         XA_MOTIF_DRAG_RECEIVER_INFO.getAtom(),
+                                         XA_MOTIF_DRAG_RECEIVER_INFO.getAtom(),
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/MotifDnDDragSourceProtocol.java openjdk/jdk/src/solaris/classes/sun/awt/X11/MotifDnDDragSourceProtocol.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/MotifDnDDragSourceProtocol.java	2010-07-15 10:28:21.905105617 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/MotifDnDDragSourceProtocol.java	2010-07-15 10:28:42.633981353 -0400
+@@ -184,7 +184,7 @@
+                                      XlibWrapper.AnyPropertyType);
+ 
+         try {
+-            int status = wpg.execute(XToolkit.IgnoreBadWindowHandler);
++            int status = wpg.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+             /*
+              * DragICCI.h:
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/MotifDnDDropTargetProtocol.java openjdk/jdk/src/solaris/classes/sun/awt/X11/MotifDnDDropTargetProtocol.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/MotifDnDDropTargetProtocol.java	2010-07-15 10:28:21.904105558 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/MotifDnDDropTargetProtocol.java	2010-07-15 10:28:42.636014780 -0400
+@@ -102,7 +102,7 @@
+                                      XlibWrapper.AnyPropertyType);
+ 
+         try {
+-            status = wpg.execute(XToolkit.IgnoreBadWindowHandler);
++            status = wpg.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+             /*
+              * DragICCI.h:
+@@ -162,7 +162,7 @@
+                 unsafe.putInt(data + 12, dataSize);
+             }
+ 
+-            XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+             XlibWrapper.XChangeProperty(XToolkit.getDisplay(), embedder,
+                                         MotifDnDConstants.XA_MOTIF_DRAG_RECEIVER_INFO.getAtom(),
+                                         MotifDnDConstants.XA_MOTIF_DRAG_RECEIVER_INFO.getAtom(),
+@@ -204,7 +204,7 @@
+                                          XlibWrapper.AnyPropertyType);
+ 
+             try {
+-                status = wpg.execute(XToolkit.IgnoreBadWindowHandler);
++                status = wpg.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                 /*
+                  * DragICCI.h:
+@@ -236,7 +236,7 @@
+ 
+                     unsafe.putInt(data + 4, tproxy);
+ 
+-                    XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++                    XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+                     XlibWrapper.XChangeProperty(XToolkit.getDisplay(), embedder,
+                                                 MotifDnDConstants.XA_MOTIF_DRAG_RECEIVER_INFO.getAtom(),
+                                                 MotifDnDConstants.XA_MOTIF_DRAG_RECEIVER_INFO.getAtom(),
+@@ -276,7 +276,7 @@
+                                      XlibWrapper.AnyPropertyType);
+ 
+         try {
+-            status = wpg.execute(XToolkit.IgnoreBadWindowHandler);
++            status = wpg.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+             /*
+              * DragICCI.h:
+@@ -325,7 +325,7 @@
+                                      XlibWrapper.AnyPropertyType);
+ 
+         try {
+-            int status = wpg.execute(XToolkit.IgnoreBadWindowHandler);
++            int status = wpg.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+             if (status == (int)XlibWrapper.Success && wpg.getData() != 0 &&
+                 wpg.getActualType() != 0 && wpg.getActualFormat() == 8 &&
+@@ -375,7 +375,7 @@
+                                          MotifDnDConstants.XA_MOTIF_DRAG_INITIATOR_INFO.getAtom());
+ 
+             try {
+-                int status = wpg.execute(XToolkit.IgnoreBadWindowHandler);
++                int status = wpg.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                 if (status == XlibWrapper.Success && wpg.getData() != 0 &&
+                     wpg.getActualType() ==
+@@ -412,7 +412,7 @@
+          */
+         XWindowAttributes wattr = new XWindowAttributes();
+         try {
+-            XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+             int status = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
+                                                           source_win, wattr.pData);
+ 
+@@ -429,7 +429,7 @@
+             wattr.dispose();
+         }
+ 
+-        XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++        XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+         XlibWrapper.XSelectInput(XToolkit.getDisplay(), source_win,
+                                  source_win_mask |
+                                  XlibWrapper.StructureNotifyMask);
+@@ -1020,7 +1020,7 @@
+         if (sourceWindow != 0) {
+             XToolkit.awtLock();
+             try {
+-                XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                 XlibWrapper.XSelectInput(XToolkit.getDisplay(), sourceWindow,
+                                          sourceWindowMask);
+                 XToolkit.RESTORE_XERROR_HANDLER();
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/WindowPropertyGetter.java openjdk/jdk/src/solaris/classes/sun/awt/X11/WindowPropertyGetter.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/WindowPropertyGetter.java	2010-07-15 10:28:21.900105578 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/WindowPropertyGetter.java	2010-07-15 10:28:42.637046074 -0400
+@@ -75,7 +75,7 @@
+     public int execute() {
+         return execute(null);
+     }
+-    public int execute(XToolkit.XErrorHandler errorHandler) {
++    public int execute(XErrorHandler errorHandler) {
+ 
+         XToolkit.awtLock();
+         try {
+@@ -94,7 +94,7 @@
+ 
+             // Fix for performance problem - IgnodeBadWindowHandler is
+             // used too much without reason, just ignore it
+-            if (errorHandler == XToolkit.IgnoreBadWindowHandler) {
++            if (errorHandler instanceof XErrorHandler.IgnoreBadWindowHandler) {
+                 errorHandler = null;
+             }
+ 
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XAWTXSettings.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XAWTXSettings.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XAWTXSettings.java	2010-07-15 10:28:21.896105637 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XAWTXSettings.java	2010-07-15 10:28:42.637981716 -0400
+@@ -122,7 +122,7 @@
+                 new WindowPropertyGetter(owner, xSettingsPropertyAtom, 0, MAX_LENGTH,
+                         false, xSettingsPropertyAtom.getAtom() );
+             try {
+-                int status = getter.execute(XToolkit.IgnoreBadWindowHandler);
++                int status = getter.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                 if (status != XlibWrapper.Success || getter.getData() == 0) {
+                     if (log.isLoggable(Level.FINE)) log.fine("OH OH : getter failed  status = " + status );
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XDecoratedPeer.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XDecoratedPeer.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XDecoratedPeer.java	2010-07-15 10:28:21.895105718 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XDecoratedPeer.java	2010-07-15 10:28:42.640232090 -0400
+@@ -1155,7 +1155,8 @@
+     }
+ 
+     boolean isOverrideRedirect() {
+-        return false;
++//        return false;
++        return ((XToolkit)Toolkit.getDefaultToolkit()).isOverrideRedirect((Window)target);
+     }
+ 
+     public boolean requestWindowFocus(long time, boolean timeProvided) {
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XDnDDragSourceProtocol.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XDnDDragSourceProtocol.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XDnDDragSourceProtocol.java	2010-07-15 10:28:21.906105640 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XDnDDragSourceProtocol.java	2010-07-15 10:28:42.642232277 -0400
+@@ -96,7 +96,7 @@
+                 action_count++;
+             }
+ 
+-            XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+             XDnDConstants.XA_XdndActionList.setAtomData(window,
+                                                         XAtom.XA_ATOM,
+                                                         data, action_count);
+@@ -117,7 +117,7 @@
+         try {
+             Native.put(data, formats);
+ 
+-            XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+             XDnDConstants.XA_XdndTypeList.setAtomData(window,
+                                                       XAtom.XA_ATOM,
+                                                       data, formats.length);
+@@ -195,7 +195,7 @@
+             new WindowPropertyGetter(window, XDnDConstants.XA_XdndAware, 0, 1,
+                                      false, XlibWrapper.AnyPropertyType);
+ 
+-        int status = wpg1.execute(XToolkit.IgnoreBadWindowHandler);
++        int status = wpg1.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+         if (status == XlibWrapper.Success &&
+             wpg1.getData() != 0 && wpg1.getActualType() == XAtom.XA_ATOM) {
+@@ -215,7 +215,7 @@
+                                              0, 1, false, XAtom.XA_WINDOW);
+ 
+                 try {
+-                    status = wpg2.execute(XToolkit.IgnoreBadWindowHandler);
++                    status = wpg2.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                     if (status == XlibWrapper.Success &&
+                         wpg2.getData() != 0 &&
+@@ -233,7 +233,7 @@
+                                                  0, 1, false, XAtom.XA_WINDOW);
+ 
+                     try {
+-                        status = wpg3.execute(XToolkit.IgnoreBadWindowHandler);
++                        status = wpg3.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                         if (status != XlibWrapper.Success ||
+                             wpg3.getData() == 0 ||
+@@ -249,7 +249,7 @@
+                                                          XlibWrapper.AnyPropertyType);
+ 
+                             try {
+-                                status = wpg4.execute(XToolkit.IgnoreBadWindowHandler);
++                                status = wpg4.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                                 if (status != XlibWrapper.Success ||
+                                     wpg4.getData() == 0 ||
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XDnDDropTargetProtocol.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XDnDDropTargetProtocol.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XDnDDropTargetProtocol.java	2010-07-15 10:28:21.903105589 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XDnDDropTargetProtocol.java	2010-07-15 10:28:42.645236553 -0400
+@@ -88,7 +88,7 @@
+         try {
+             Native.putLong(data, 0, XDnDConstants.XDND_PROTOCOL_VERSION);
+ 
+-            XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+             XDnDConstants.XA_XdndAware.setAtomData(window, XAtom.XA_ATOM, data, 1);
+             XToolkit.RESTORE_XERROR_HANDLER();
+ 
+@@ -122,7 +122,7 @@
+                                      false, XlibWrapper.AnyPropertyType);
+ 
+         try {
+-            status = wpg1.execute(XToolkit.IgnoreBadWindowHandler);
++            status = wpg1.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+             if (status == XlibWrapper.Success &&
+                 wpg1.getData() != 0 && wpg1.getActualType() == XAtom.XA_ATOM) {
+@@ -141,7 +141,7 @@
+                                          0, 1, false, XAtom.XA_WINDOW);
+ 
+             try {
+-                status = wpg2.execute(XToolkit.IgnoreBadWindowHandler);
++                status = wpg2.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                 if (status == XlibWrapper.Success &&
+                     wpg2.getData() != 0 &&
+@@ -159,7 +159,7 @@
+                                              0, 1, false, XAtom.XA_WINDOW);
+ 
+                 try {
+-                    status = wpg3.execute(XToolkit.IgnoreBadWindowHandler);
++                    status = wpg3.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                     if (status != XlibWrapper.Success ||
+                         wpg3.getData() == 0 ||
+@@ -175,7 +175,7 @@
+                                                      XlibWrapper.AnyPropertyType);
+ 
+                         try {
+-                            status = wpg4.execute(XToolkit.IgnoreBadWindowHandler);
++                            status = wpg4.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                             if (status != XlibWrapper.Success ||
+                                 wpg4.getData() == 0 ||
+@@ -205,7 +205,7 @@
+ 
+             /* The proxy window must have the XdndAware set, as XDnD protocol
+                prescribes to check the proxy window for XdndAware. */
+-            XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+             XDnDConstants.XA_XdndAware.setAtomData(newProxy, XAtom.XA_ATOM,
+                                                    data, 1);
+             XToolkit.RESTORE_XERROR_HANDLER();
+@@ -219,7 +219,7 @@
+             Native.putLong(data, 0, newProxy);
+ 
+             /* The proxy window must have the XdndProxy set to point to itself.*/
+-            XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+             XDnDConstants.XA_XdndProxy.setAtomData(newProxy, XAtom.XA_WINDOW,
+                                                    data, 1);
+             XToolkit.RESTORE_XERROR_HANDLER();
+@@ -232,7 +232,7 @@
+ 
+             Native.putLong(data, 0, XDnDConstants.XDND_PROTOCOL_VERSION);
+ 
+-            XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+             XDnDConstants.XA_XdndAware.setAtomData(embedder, XAtom.XA_ATOM,
+                                                    data, 1);
+             XToolkit.RESTORE_XERROR_HANDLER();
+@@ -245,7 +245,7 @@
+ 
+             Native.putLong(data, 0, newProxy);
+ 
+-            XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+             XDnDConstants.XA_XdndProxy.setAtomData(embedder, XAtom.XA_WINDOW,
+                                                    data, 1);
+             XToolkit.RESTORE_XERROR_HANDLER();
+@@ -278,7 +278,7 @@
+             try {
+                 Native.putLong(data, 0, entry.getVersion());
+ 
+-                XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+                 XDnDConstants.XA_XdndAware.setAtomData(embedder, XAtom.XA_ATOM,
+                                                        data, 1);
+                 XToolkit.RESTORE_XERROR_HANDLER();
+@@ -291,7 +291,7 @@
+ 
+                 Native.putLong(data, 0, (int)entry.getProxy());
+ 
+-                XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+                 XDnDConstants.XA_XdndProxy.setAtomData(embedder, XAtom.XA_WINDOW,
+                                                        data, 1);
+                 XToolkit.RESTORE_XERROR_HANDLER();
+@@ -329,7 +329,7 @@
+                                      false, XlibWrapper.AnyPropertyType);
+ 
+         try {
+-            status = wpg1.execute(XToolkit.IgnoreBadWindowHandler);
++            status = wpg1.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+             if (status == XlibWrapper.Success &&
+                 wpg1.getData() != 0 && wpg1.getActualType() == XAtom.XA_ATOM) {
+@@ -348,7 +348,7 @@
+                                          0, 1, false, XAtom.XA_WINDOW);
+ 
+             try {
+-                status = wpg2.execute(XToolkit.IgnoreBadWindowHandler);
++                status = wpg2.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                 if (status == XlibWrapper.Success &&
+                     wpg2.getData() != 0 &&
+@@ -366,7 +366,7 @@
+                                              0, 1, false, XAtom.XA_WINDOW);
+ 
+                 try {
+-                    status = wpg3.execute(XToolkit.IgnoreBadWindowHandler);
++                    status = wpg3.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                     if (status != XlibWrapper.Success ||
+                         wpg3.getData() == 0 ||
+@@ -382,7 +382,7 @@
+                                                      XlibWrapper.AnyPropertyType);
+ 
+                         try {
+-                            status = wpg4.execute(XToolkit.IgnoreBadWindowHandler);
++                            status = wpg4.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                             if (status != XlibWrapper.Success ||
+                                 wpg4.getData() == 0 ||
+@@ -411,7 +411,7 @@
+                                      false, XlibWrapper.AnyPropertyType);
+ 
+         try {
+-            int status = wpg1.execute(XToolkit.IgnoreBadWindowHandler);
++            int status = wpg1.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+             if (status == XlibWrapper.Success &&
+                 wpg1.getData() != 0 && wpg1.getActualType() == XAtom.XA_ATOM) {
+@@ -473,7 +473,7 @@
+                                          0, 0xFFFF, false,
+                                          XAtom.XA_ATOM);
+             try {
+-                wpg.execute(XToolkit.IgnoreBadWindowHandler);
++                wpg.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                 if (wpg.getActualType() == XAtom.XA_ATOM &&
+                     wpg.getActualFormat() == 32) {
+@@ -505,7 +505,7 @@
+                                          0, 0xFFFF, false,
+                                          XAtom.XA_ATOM);
+             try {
+-                wpg.execute(XToolkit.IgnoreBadWindowHandler);
++                wpg.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                 if (wpg.getActualType() == XAtom.XA_ATOM &&
+                     wpg.getActualFormat() == 32) {
+@@ -541,7 +541,7 @@
+          */
+         XWindowAttributes wattr = new XWindowAttributes();
+         try {
+-            XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+             int status = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
+                                                           source_win, wattr.pData);
+ 
+@@ -558,7 +558,7 @@
+             wattr.dispose();
+         }
+ 
+-        XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++        XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+         XlibWrapper.XSelectInput(XToolkit.getDisplay(), source_win,
+                                  source_win_mask |
+                                  XlibWrapper.StructureNotifyMask);
+@@ -963,7 +963,7 @@
+         if (sourceWindow != 0) {
+             XToolkit.awtLock();
+             try {
+-                XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                 XlibWrapper.XSelectInput(XToolkit.getDisplay(), sourceWindow,
+                                          sourceWindowMask);
+                 XToolkit.RESTORE_XERROR_HANDLER();
+@@ -1104,14 +1104,14 @@
+                                                  0, 0xFFFF, false,
+                                                  XAtom.XA_ATOM);
+                     try {
+-                        wpg.execute(XToolkit.IgnoreBadWindowHandler);
++                        wpg.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+                         if (wpg.getActualType() == XAtom.XA_ATOM &&
+                             wpg.getActualFormat() == 32) {
+ 
+                             XToolkit.awtLock();
+                             try {
+-                                XToolkit.WITH_XERROR_HANDLER(XWM.VerifyChangePropertyHandler);
++                                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+                                 XDnDConstants.XA_XdndTypeList.setAtomData(xclient.get_window(),
+                                                                           XAtom.XA_ATOM,
+                                                                           wpg.getData(),
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XDragSourceProtocol.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XDragSourceProtocol.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XDragSourceProtocol.java	2010-07-15 10:28:21.896105637 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XDragSourceProtocol.java	2010-07-15 10:28:42.646232066 -0400
+@@ -181,7 +181,7 @@
+                                    long time) {
+         XWindowAttributes wattr = new XWindowAttributes();
+         try {
+-            XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+             int status = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
+                                                           targetWindow, wattr.pData);
+ 
+@@ -198,7 +198,7 @@
+             wattr.dispose();
+         }
+ 
+-        XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++        XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+         XlibWrapper.XSelectInput(XToolkit.getDisplay(), targetWindow,
+                                  targetWindowMask |
+                                  XlibWrapper.StructureNotifyMask);
+@@ -214,7 +214,7 @@
+     }
+ 
+     protected final void finalizeDrop() {
+-        XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++        XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+         XlibWrapper.XSelectInput(XToolkit.getDisplay(), targetWindow,
+                                  targetWindowMask);
+         XToolkit.RESTORE_XERROR_HANDLER();
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XDropTargetRegistry.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XDropTargetRegistry.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XDropTargetRegistry.java	2010-07-15 10:28:21.906105640 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XDropTargetRegistry.java	2010-07-15 10:28:42.648232198 -0400
+@@ -172,7 +172,7 @@
+                 if (dest_x >= 0 && dest_y >= 0) {
+                     XWindowAttributes wattr = new XWindowAttributes();
+                     try {
+-                        XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++                        XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                         int status = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
+                                                                       window, wattr.pData);
+                         XToolkit.RESTORE_XERROR_HANDLER();
+@@ -226,7 +226,7 @@
+             long event_mask = 0;
+             XWindowAttributes wattr = new XWindowAttributes();
+             try {
+-                XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                 int status = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
+                                                               embedder, wattr.pData);
+                 XToolkit.RESTORE_XERROR_HANDLER();
+@@ -244,7 +244,7 @@
+             }
+ 
+             if ((event_mask & XlibWrapper.PropertyChangeMask) == 0) {
+-                XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                 XlibWrapper.XSelectInput(XToolkit.getDisplay(), embedder,
+                                          event_mask | XlibWrapper.PropertyChangeMask);
+                 XToolkit.RESTORE_XERROR_HANDLER();
+@@ -398,7 +398,7 @@
+ 
+             /* Restore the original event mask for the embedder. */
+             if ((event_mask & XlibWrapper.PropertyChangeMask) == 0) {
+-                XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                 XlibWrapper.XSelectInput(XToolkit.getDisplay(), embedder,
+                                          event_mask);
+                 XToolkit.RESTORE_XERROR_HANDLER();
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XEmbedCanvasPeer.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XEmbedCanvasPeer.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XEmbedCanvasPeer.java	2010-07-15 10:28:21.897105547 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XEmbedCanvasPeer.java	2010-07-15 10:28:42.650232331 -0400
+@@ -301,7 +301,7 @@
+         try {
+             XWindowAttributes wattr = new XWindowAttributes();
+             try {
+-                XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                 int status = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
+                                                               xembed.handle, wattr.pData);
+ 
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XErrorHandler.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XErrorHandler.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XErrorHandler.java	1969-12-31 19:00:00.000000000 -0500
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XErrorHandler.java	2010-07-15 10:28:42.651989313 -0400
+@@ -0,0 +1,79 @@
++/*
++ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
++ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++ *
++ * This code is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License version 2 only, as
++ * published by the Free Software Foundation.  Sun designates this
++ * particular file as subject to the "Classpath" exception as provided
++ * by Sun in the LICENSE file that accompanied this code.
++ *
++ * This code is distributed in the hope that it will be useful, but WITHOUT
++ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
++ * version 2 for more details (a copy is included in the LICENSE file that
++ * accompanied this code).
++ *
++ * You should have received a copy of the GNU General Public License version
++ * 2 along with this work; if not, write to the Free Software Foundation,
++ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
++ *
++ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
++ * CA 95054 USA or visit www.sun.com if you need additional information or
++ * have any questions.
++ */
++package sun.awt.X11;
++
++public abstract class XErrorHandler {
++
++    /*
++     * Called under AWT lock
++     */
++    public abstract int handleError(long display, XErrorEvent err);
++
++    /*
++     * Forwards all the errors to saved error handler (which was
++     * set before XToolkit had been initialized).
++     */
++    public static class XBaseErrorHandler extends XErrorHandler {
++        @Override
++        public int handleError(long display, XErrorEvent err) {
++            return XToolkit.SAVED_ERROR_HANDLER(display, err);
++        }
++    }
++
++    /*
++     * Instead of validating window id, we simply call XGetWindowProperty,
++     * but temporary install this function as the error handler to ignore
++     * BadWindow error.
++     */
++    public static class IgnoreBadWindowHandler extends XBaseErrorHandler {
++        @Override
++        public int handleError(long display, XErrorEvent err) {
++            if (err.get_error_code() == XConstants.BadWindow) {
++                return 0;
++            }
++            return super.handleError(display, err);
++        }
++        // Shared instance
++        private static IgnoreBadWindowHandler theInstance = new IgnoreBadWindowHandler();
++        public static IgnoreBadWindowHandler getInstance() {
++            return theInstance;
++        }
++    }
++
++    public static class VerifyChangePropertyHandler extends XBaseErrorHandler {
++        @Override
++        public int handleError(long display, XErrorEvent err) {
++            if (err.get_request_code() == XProtocolConstants.X_ChangeProperty) {
++                return 0;
++            }
++            return super.handleError(display, err);
++        }
++        // Shared instance
++        private static IgnoreBadWindowHandler theInstance = new IgnoreBadWindowHandler();
++        public static IgnoreBadWindowHandler getInstance() {
++            return theInstance;
++        }
++    }
++}
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XlibUtil.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XlibUtil.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XlibUtil.java	2010-07-15 10:28:21.893105473 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XlibUtil.java	2010-07-15 10:28:42.651989313 -0400
+@@ -149,7 +149,7 @@
+                 new XTranslateCoordinates(src, dst, p.x, p.y);
+             try
+             {
+-                int status = xtc.execute(XToolkit.IgnoreBadWindowHandler);
++                int status = xtc.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                 if ((status != 0) &&
+                     ((XToolkit.saved_error == null) ||
+                      (XToolkit.saved_error.get_error_code() == XlibWrapper.Success)))
+@@ -306,7 +306,7 @@
+                                          XWM.XA_WM_STATE);
+             try
+             {
+-                wpg.execute(XToolkit.IgnoreBadWindowHandler);
++                wpg.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                 if (wpg.getActualType() == XWM.XA_WM_STATE.getAtom())
+                 {
+                     return true;
+@@ -345,7 +345,7 @@
+         XWindowAttributes wattr = new XWindowAttributes();
+         try
+         {
+-            XToolkit.WITH_XERROR_HANDLER(XToolkit.IgnoreBadWindowHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+             int status = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
+                                                           window, wattr.pData);
+             XToolkit.RESTORE_XERROR_HANDLER();
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XlibWrapper.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XlibWrapper.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XlibWrapper.java	2010-07-15 10:28:21.905105617 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XlibWrapper.java	2010-07-15 10:28:42.654187919 -0400
+@@ -613,4 +613,6 @@
+         String javaVersion = XToolkit.getSystemProperty("java.version");
+         return javaVersion != null && javaVersion.contains("internal");
+     }
++
++    static native void PrintXErrorEvent(long display, long event_ptr);
+ }
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XProtocol.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XProtocol.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XProtocol.java	2010-07-15 10:28:21.893105473 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XProtocol.java	2010-07-15 10:28:42.655357930 -0400
+@@ -35,20 +35,6 @@
+     private Map<XAtom, XAtomList> atomToList = new HashMap<XAtom, XAtomList>();
+     private Map<XAtom, Long> atomToAnchor = new HashMap<XAtom, Long>();
+ 
+-    /*
+-     * Temporary error handler that ensures that we know if
+-     * XChangeProperty succeeded or not.
+-     */
+-    static XToolkit.XErrorHandler VerifyChangePropertyHandler = new XToolkit.XErrorHandler() {
+-            public int handleError(long display, XErrorEvent err) {
+-                XToolkit.XERROR_SAVE(err);
+-                if (err.get_request_code() == XlibWrapper.X_ChangeProperty) {
+-                    return 0;
+-                } else {
+-                    return XToolkit.SAVED_ERROR_HANDLER(display, err);
+-                }
+-            }
+-        };
+     volatile boolean firstCheck = true;
+     /*
+      * Check that that the list of protocols specified by WM in property
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XQueryTree.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XQueryTree.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XQueryTree.java	2010-07-15 10:28:21.894105746 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XQueryTree.java	2010-07-15 10:28:42.662356819 -0400
+@@ -51,7 +51,7 @@
+         public int execute() {
+                 return execute(null);
+         }
+-        public int execute(XToolkit.XErrorHandler errorHandler) {
++        public int execute(XErrorHandler errorHandler) {
+                 XToolkit.awtLock();
+                 try {
+                     if (isDisposed()) {
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XToolkit.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XToolkit.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XToolkit.java	2010-07-15 10:28:21.896105637 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XToolkit.java	2010-07-15 10:30:45.039232001 -0400
+@@ -48,6 +48,7 @@
+ import sun.font.FontManager;
+ import sun.misc.PerformanceLogger;
+ import sun.print.PrintJob2D;
++import sun.security.action.GetBooleanAction;
+ import java.lang.reflect.*;
+ 
+ public class XToolkit extends UNIXToolkit implements Runnable, XConstants {
+@@ -120,62 +121,78 @@
+             setBackingStoreType();
+         }
+         m_removeSourceEvents = SunToolkit.getMethod(EventQueue.class, "removeSourceEvents", new Class[] {Object.class, Boolean.TYPE}) ;
++        noisyAwtHandler = AccessController.doPrivileged(new GetBooleanAction("sun.awt.noisyerrorhandler"));
++
+     }
+ 
+-    // Error handler stuff
+-    static XErrorEvent saved_error;
+-    static long saved_error_handler;
+-    static XErrorHandler curErrorHandler;
+-    // Should be called under LOCK, before releasing LOCK RESTORE_XERROR_HANDLER should be called
+-    static void WITH_XERROR_HANDLER(XErrorHandler handler) {
++    //---- ERROR HANDLER CODE ----//
++
++    /*
++     * Error handler at the moment of XToolkit initialization
++     */
++    private static long saved_error_handler;
++
++    /*
++     * XErrorEvent being handled
++     */
++    static volatile XErrorEvent saved_error;
++
++    /*
++     * Current error handler or null if no error handler is set
++     */
++    private static XErrorHandler current_error_handler;
++
++    /*
++     * Value of sun.awt.noisyerrorhandler system property
++     */
++    private static boolean noisyAwtHandler;
++
++    public static void WITH_XERROR_HANDLER(XErrorHandler handler) {
+         saved_error = null;
+-        curErrorHandler = handler;
+-        XSync();
+-        saved_error_handler = XlibWrapper.SetToolkitErrorHandler();
+-    }
+-    static void XERROR_SAVE(XErrorEvent event) {
+-        saved_error = event;
++        current_error_handler = handler;
+     }
+-    // Should be called under LOCK
+-    static void RESTORE_XERROR_HANDLER() {
+-       XSync();
+-        XlibWrapper.XSetErrorHandler(saved_error_handler);
+-        curErrorHandler = null;
++
++    public static void RESTORE_XERROR_HANDLER() {
++        current_error_handler = null;
+     }
++
+     // Should be called under LOCK
+-    static int SAVED_ERROR_HANDLER(long display, XErrorEvent error) {
+-        return XlibWrapper.CallErrorHandler(saved_error_handler, display, error.pData);
+-    }
+-    interface XErrorHandler {
+-        int handleError(long display, XErrorEvent err);
++    public static int SAVED_ERROR_HANDLER(long display, XErrorEvent error) {
++        if (saved_error_handler != 0) {
++            // Default XErrorHandler may just terminate the process. Don't call it.
++            // return XlibWrapper.CallErrorHandler(saved_error_handler, display, error.pData);
++        }
++        if (log.isLoggable(Level.FINE)) {
++            log.log(Level.FINE, "Unhandled XErrorEvent: " +
++                    "id=" + error.get_resourceid() + ", " +
++                    "serial=" + error.get_serial() + ", " +
++                    "ec=" + error.get_error_code() + ", " +
++                    "rc=" + error.get_request_code() + ", " +
++                    "mc=" + error.get_minor_code());
++        }
++        return 0;
+     }
+-    static int GlobalErrorHandler(long display, long event_ptr) {
++
++    // Called from the native code when an error occurs
++    private static int globalErrorHandler(long display, long event_ptr) {
++        if (noisyAwtHandler) {
++            XlibWrapper.PrintXErrorEvent(display, event_ptr);
++        }
+         XErrorEvent event = new XErrorEvent(event_ptr);
++        saved_error = event;
+         try {
+-            if (curErrorHandler != null) {
+-                return curErrorHandler.handleError(display, event);
++            if (current_error_handler != null) {
++                return current_error_handler.handleError(display, event);
+             } else {
+                 return SAVED_ERROR_HANDLER(display, event);
+             }
+-        } finally {
++        } catch (Throwable z) {
++            log.log(Level.FINE, "Error in GlobalErrorHandler", z);
+         }
++        return 0;
+     }
+ 
+-/*
+- * Instead of validating window id, we simply call XGetWindowProperty,
+- * but temporary install this function as the error handler to ignore
+- * BadWindow error.
+- */
+-    static XErrorHandler IgnoreBadWindowHandler = new XErrorHandler() {
+-            public int handleError(long display, XErrorEvent err) {
+-                XERROR_SAVE(err);
+-                if (err.get_error_code() == BadWindow) {
+-                    return 0;
+-                } else {
+-                    return SAVED_ERROR_HANDLER(display, err);
+-                }
+-            }
+-        };
++    //---- END OF ERROR HANDLER CODE ----//
+ 
+ 
+     private native static void initIDs();
+@@ -269,17 +286,27 @@
+ 
+             arrowCursor = XlibWrapper.XCreateFontCursor(XToolkit.getDisplay(),
+                 XCursorFontConstants.XC_arrow);
++
++            saved_error_handler = XlibWrapper.SetToolkitErrorHandler();
++
+         } finally {
+             awtUnlock();
+         }
+ 
+-        if (log.isLoggable(Level.FINE)) {
+-            Runtime.getRuntime().addShutdownHook(new Thread() {
+-                    public void run() {
++        Runtime.getRuntime().addShutdownHook(new Thread() {
++            public void run() {
++                if (log.isLoggable(Level.FINE)) {
+                         dumpPeers();
+-                    }
+-                });
+-        }
++                }
++
++                awtLock();
++                try {
++                        XlibWrapper.XSetErrorHandler(saved_error_handler);
++                } finally {
++                        awtUnlock();
++                }
++            }
++        });
+     }
+ 
+     static String getCorrectXIDString(String val) {
+@@ -2162,5 +2189,4 @@
+         return new XDesktopPeer();
+     }
+ 
+-    public static native void setNoisyXErrorHandler();
+ }
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XTranslateCoordinates.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XTranslateCoordinates.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XTranslateCoordinates.java	2010-07-15 10:28:21.900105578 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XTranslateCoordinates.java	2010-07-15 10:28:42.666356882 -0400
+@@ -57,7 +57,7 @@
+         public int execute() {
+                 return execute(null);
+         }
+-        public int execute(XToolkit.XErrorHandler errorHandler) {
++        public int execute(XErrorHandler errorHandler) {
+                 XToolkit.awtLock();
+                 try {
+                 if (isDisposed()) {
+diff -uNr openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XWM.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XWM.java
+--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XWM.java	2010-07-15 10:28:21.896105637 -0400
++++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XWM.java	2010-07-15 10:28:42.668356704 -0400
+@@ -273,7 +273,7 @@
+             winmgr_running = false;
+             substruct.set_event_mask(XlibWrapper.SubstructureRedirectMask);
+ 
+-            XToolkit.WITH_XERROR_HANDLER(DetectWMHandler);
++            XToolkit.WITH_XERROR_HANDLER(detectWMHandler);
+             XlibWrapper.XChangeWindowAttributes(XToolkit.getDisplay(),
+                                                 XToolkit.getDefaultRootWindow(),
+                                                 XlibWrapper.CWEventMask,
+@@ -318,7 +318,7 @@
+             new WindowPropertyGetter(window, XA_ENLIGHTENMENT_COMMS, 0, 14, false,
+                                      XAtom.XA_STRING);
+         try {
+-            int status = getter.execute(XToolkit.IgnoreBadWindowHandler);
++            int status = getter.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+             if (status != XlibWrapper.Success || getter.getData() == 0) {
+                 return 0;
+             }
+@@ -442,7 +442,7 @@
+                 new WindowPropertyGetter(wmwin, XA_DT_SM_STATE_INFO, 0, 1,
+                                          false, XA_DT_SM_STATE_INFO);
+             try {
+-                status = getter2.execute(XToolkit.IgnoreBadWindowHandler);
++                status = getter2.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+ 
+ 
+                 if (status != XlibWrapper.Success || getter2.getData() == 0) {
+@@ -574,21 +574,6 @@
+     }
+ 
+     /*
+-     * Temporary error handler that ensures that we know if
+-     * XChangeProperty succeeded or not.
+-     */
+-    static XToolkit.XErrorHandler VerifyChangePropertyHandler = new XToolkit.XErrorHandler() {
+-            public int handleError(long display, XErrorEvent err) {
+-                XToolkit.XERROR_SAVE(err);
+-                if (err.get_request_code() == XlibWrapper.X_ChangeProperty) {
+-                    return 0;
+-                } else {
+-                    return XToolkit.SAVED_ERROR_HANDLER(display, err);
+-                }
+-            }
+-        };
+-
+-    /*
+      * Prepare IceWM check.
+      *
+      * The only way to detect IceWM, seems to be by setting
+@@ -623,7 +608,7 @@
+ 
+         XToolkit.awtLock();
+         try {
+-            XToolkit.WITH_XERROR_HANDLER(VerifyChangePropertyHandler);
++            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+             XlibWrapper.XChangePropertyS(XToolkit.getDisplay(), XToolkit.getDefaultRootWindow(),
+                                          XA_ICEWM_WINOPTHINT.getAtom(),
+                                          XA_ICEWM_WINOPTHINT.getAtom(),
+@@ -691,20 +676,19 @@
+      * Temporary error handler that checks if selecting for
+      * SubstructureRedirect failed.
+      */
+-    static boolean winmgr_running = false;
+-    static XToolkit.XErrorHandler DetectWMHandler = new XToolkit.XErrorHandler() {
+-            public int handleError(long display, XErrorEvent err) {
+-                XToolkit.XERROR_SAVE(err);
+-                if (err.get_request_code() == XlibWrapper.X_ChangeWindowAttributes
+-                    && err.get_error_code() == XlibWrapper.BadAccess)
+-                {
+-                    winmgr_running = true;
+-                    return 0;
+-                } else {
+-                    return XToolkit.SAVED_ERROR_HANDLER(display, err);
+-                }
++    private static boolean winmgr_running = false;
++    private static XErrorHandler detectWMHandler = new XErrorHandler.XBaseErrorHandler() {
++        @Override
++        public int handleError(long display, XErrorEvent err) {
++            if ((err.get_request_code() == XProtocolConstants.X_ChangeWindowAttributes) &&
++                (err.get_error_code() == XConstants.BadAccess))
++            {
++                winmgr_running = true;
++                return 0;
+             }
+-        };
++            return super.handleError(display, err);
++        }
++    };
+ 
+     /*
+      * Make an educated guess about running window manager.
+diff -uNr openjdk.orig/jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c openjdk/jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c
+--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	2010-07-15 10:28:21.866105645 -0400
++++ openjdk/jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	2010-07-15 10:28:42.670355820 -0400
+@@ -175,42 +175,11 @@
+ }
+ 
+ #ifndef HEADLESS
++
+ /*
+- * error handlers
++ * XIOErrorHandler
+  */
+-
+-int
+-xerror_handler(Display * disp, XErrorEvent * err)
+-{
+-/* #ifdef DEBUG */
+-    char msg[128];
+-    char buf[128];
+-    char *ev = getenv("NOISY_AWT");
+-
+-    if (!ev || !ev[0])
+-        return 0;
+-    XGetErrorText(disp, err->error_code, msg, sizeof(msg));
+-    jio_fprintf(stderr, "Xerror %s, XID %x, ser# %d\n", msg, err->resourceid, err->serial);
+-    jio_snprintf(buf, sizeof(buf), "%d", err->request_code);
+-    XGetErrorDatabaseText(disp, "XRequest", buf, "Unknown", msg, sizeof(msg));
+-    jio_fprintf(stderr, "Major opcode %d (%s)\n", err->request_code, msg);
+-    if (err->request_code > 128) {
+-        jio_fprintf(stderr, "Minor opcode %d\n", err->minor_code);
+-    }
+-    if (awtLockInited) {
+-        /*SignalError(lockedee->lastpc, lockedee, "fp/ade/gui/GUIException", msg); */
+-    }
+-    if (strcasecmp(ev, "abort") == 0) {
+-        JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
+-
+-        (*env)->FatalError(env, "xerror_handler abort");
+-    }
+-/* #endif */
+-    return 0;
+-}
+-
+-static int
+-xioerror_handler(Display * disp)
++static int xioerror_handler(Display *disp)
+ {
+     if (awtLockInited) {
+         if (errno == EPIPE) {
+@@ -806,7 +775,6 @@
+         return NULL;
+     }
+ 
+-    XSetErrorHandler(xerror_handler);
+     XSetIOErrorHandler(xioerror_handler);
+ 
+     /* set awt_numScreens, and whether or not we're using Xinerama */
+diff -uNr openjdk.orig/jdk/src/solaris/native/sun/awt/awt_InputMethod.c openjdk/jdk/src/solaris/native/sun/awt/awt_InputMethod.c
+--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_InputMethod.c	2010-07-15 10:28:21.865105640 -0400
++++ openjdk/jdk/src/solaris/native/sun/awt/awt_InputMethod.c	2010-07-15 10:28:42.671355975 -0400
+@@ -1458,7 +1458,6 @@
+ }
+ 
+ static void OpenXIMCallback(Display *display, XPointer client_data, XPointer call_data) {
+-    extern int xerror_handler();
+     XIMCallback ximCallback;
+ 
+     X11im = XOpenIM(display, NULL, NULL, NULL);
+@@ -1469,13 +1468,6 @@
+     ximCallback.callback = (XIMProc)DestroyXIMCallback;
+     ximCallback.client_data = NULL;
+     XSetIMValues(X11im, XNDestroyCallback, &ximCallback, NULL);
+-
+-    /* Workaround for Solaris 2.6 bug 4097754. We're affected by this problem
+-     * because Motif also calls XOpenIM for us. Re-registering the error handler
+-     * that MToolkit has registered already after calling XOpenIM avoids the
+-     * problem.
+-     */
+-    XSetErrorHandler(xerror_handler);
+ }
+ 
+ static void DestroyXIMCallback(XIM im, XPointer client_data, XPointer call_data) {
+diff -uNr openjdk.orig/jdk/src/solaris/native/sun/awt/awt_MToolkit.c openjdk/jdk/src/solaris/native/sun/awt/awt_MToolkit.c
+--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_MToolkit.c	2010-07-15 10:28:21.867105700 -0400
++++ openjdk/jdk/src/solaris/native/sun/awt/awt_MToolkit.c	2010-07-15 10:28:42.673355929 -0400
+@@ -1926,26 +1926,6 @@
+               XtAppProcessEvent(awt_appContext, iMask & ~XtIMXEvent);
+             }
+ 
+-            /*
+-            ** Bug #4361799: Forte4J sometimes crashes on Solaris:
+-            ** There is an underlying bug in Selection.c in Xt lib.
+-            ** The routine HandleSelectionEvents, can call EndProtectedSection()
+-            ** more than  StartProtectedSection(), and then EndProtectedSection
+-            ** will restore the default XError handler.  As a result awt's
+-            ** XError handler gets removed and we later crash on an XError.
+-            **
+-            ** This happens when we call XtAppProcessEvent with event type 1e
+-            ** (SelectionRequest) when running two copies of Forte
+-            **
+-            ** XSetErrorHandler can safely be called repeatedly, so we are
+-            ** fixing this with the sledgehammer, and resetting our XError
+-            ** handler every time through the loop:
+-            */
+-            {
+-                extern int32_t xerror_handler();
+-                XSetErrorHandler(xerror_handler);
+-            }
+-
+ } /* processOneEvent() */
+ 
+ /*
+diff -uNr openjdk.orig/jdk/src/solaris/native/sun/xawt/XlibWrapper.c openjdk/jdk/src/solaris/native/sun/xawt/XlibWrapper.c
+--- openjdk.orig/jdk/src/solaris/native/sun/xawt/XlibWrapper.c	2010-07-15 10:28:21.882105738 -0400
++++ openjdk/jdk/src/solaris/native/sun/xawt/XlibWrapper.c	2010-07-15 10:28:42.675169363 -0400
+@@ -1097,7 +1097,7 @@
+ static int ToolkitErrorHandler(Display * dpy, XErrorEvent * event) {
+     if (jvm != NULL) {
+         JNIEnv * env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
+-        return JNU_CallStaticMethodByName(env, NULL, "sun/awt/X11/XToolkit", "GlobalErrorHandler", "(JJ)I",
++        return JNU_CallStaticMethodByName(env, NULL, "sun/awt/X11/XToolkit", "globalErrorHandler", "(JJ)I",
+                                           ptr_to_jlong(dpy), ptr_to_jlong(event)).i;
+     } else {
+         return 0;
+@@ -1140,6 +1140,28 @@
+     return (*(XErrorHandler)jlong_to_ptr(handler))((Display*) jlong_to_ptr(display), (XErrorEvent*) jlong_to_ptr(event_ptr));
+ }
+ 
++/*
++ * Class:     sun_awt_X11_XlibWrapper
++ * Method:    PrintXErrorEvent
++ * Signature: (JJ)V
++ */
++JNIEXPORT void JNICALL Java_sun_awt_X11_XlibWrapper_PrintXErrorEvent
++(JNIEnv *env, jclass clazz, jlong display, jlong event_ptr)
++{
++    char msg[128];
++    char buf[128];
++
++    XErrorEvent* err = (XErrorEvent *)jlong_to_ptr(event_ptr);
++
++    XGetErrorText((Display *)jlong_to_ptr(display), err->error_code, msg, sizeof(msg));
++    jio_fprintf(stderr, "Xerror %s, XID %x, ser# %d\n", msg, err->resourceid, err->serial);
++    jio_snprintf(buf, sizeof(buf), "%d", err->request_code);
++    XGetErrorDatabaseText((Display *)jlong_to_ptr(display), "XRequest", buf, "Unknown", msg, sizeof(msg));
++    jio_fprintf(stderr, "Major opcode %d (%s)\n", err->request_code, msg);
++    if (err->request_code > 128) {
++        jio_fprintf(stderr, "Minor opcode %d\n", err->minor_code);
++    }
++}
+ 
+ 
+ /*
+diff -uNr openjdk.orig/jdk/src/solaris/native/sun/xawt/XToolkit.c openjdk/jdk/src/solaris/native/sun/xawt/XToolkit.c
+--- openjdk.orig/jdk/src/solaris/native/sun/xawt/XToolkit.c	2010-07-15 10:28:21.883105599 -0400
++++ openjdk/jdk/src/solaris/native/sun/xawt/XToolkit.c	2010-07-15 10:28:42.676355933 -0400
+@@ -581,7 +581,6 @@
+         pollFds[1].revents = 0;
+     }
+ 
+-
+     AWT_NOFLUSH_UNLOCK();
+ 
+     /* ACTUALLY DO THE POLL() */
+@@ -690,8 +689,6 @@
+     return ret;
+ }
+ 
+-static XErrorHandler saved_error_handler = NULL;
+-
+ #ifdef __linux__
+ void print_stack(void)
+ {
+@@ -712,38 +709,6 @@
+ }
+ #endif
+ 
+-static int NoisyXErrorHandler(Display * dpy, XErrorEvent * event) {
+-    fprintf(stderr, "id=%x, serial=%x, ec=%d, rc=%d, mc=%d\n",
+-            event->resourceid, event->serial, event->error_code,
+-            event->request_code, event->minor_code);
+-    /*
+-    #ifdef __linux__
+-        print_stack();
+-    #endif
+-    */
+-    if (jvm != NULL) {
+-      JNIEnv * env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
+-      JNU_CallStaticMethodByName(env, NULL, "java/lang/Thread", "dumpStack", "()V");
+-    }
+-    if (!saved_error_handler) {
+-        return saved_error_handler(dpy, event);
+-    }
+-    return 0;
+-}
+-
+-/*
+- * Class:     sun_awt_X11_XToolkit
+- * Method:    setNoisyXErrorHandler
+- * Signature: ()V
+- */
+-JNIEXPORT void JNICALL Java_sun_awt_X11_XToolkit_setNoisyXErrorHandler
+-(JNIEnv *env , jclass clazz)
+-{
+-    (*env)->GetJavaVM(env, &jvm);
+-    saved_error_handler = XSetErrorHandler(NoisyXErrorHandler);
+-}
+-
+-
+ Window get_xawt_root_shell(JNIEnv *env) {
+   static jclass classXRootWindow = NULL;
+   static jmethodID methodGetXRootWindow = NULL;
diff -r d1ad52447673 patches/systemtap-gcc-4.5.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/patches/systemtap-gcc-4.5.patch	Tue Jul 20 16:36:52 2010 +0200
@@ -0,0 +1,11 @@
+--- openjdk.orig/hotspot/src/share/vm/prims/jni.cpp	2010-04-28 08:51:29.000000000 +0100
++++ openjdk/hotspot/src/share/vm/prims/jni.cpp	2010-04-28 09:29:22.000000000 +0100
+@@ -2723,7 +2723,7 @@
+ 
+   if (!directBufferSupportInitializeEnded) {
+     if (!initializeDirectBufferSupport(env, thread)) {
+-      DTRACE_PROBE1(hotspot_jni, NewDirectByteBuffer__return, NULL);
++      DTRACE_PROBE1(hotspot_jni, NewDirectByteBuffer__return, (uintptr_t) NULL);
+       return NULL;
+     }
+   }
diff -r d1ad52447673 plugin/icedteanp/IcedTeaJavaRequestProcessor.cc
--- a/plugin/icedteanp/IcedTeaJavaRequestProcessor.cc	Wed Apr 14 12:21:30 2010 +0200
+++ b/plugin/icedteanp/IcedTeaJavaRequestProcessor.cc	Tue Jul 20 16:36:52 2010 +0200
@@ -179,7 +179,7 @@
 
 JavaRequestProcessor::JavaRequestProcessor()
 {
-    PLUGIN_DEBUG_0ARG("JavaRequestProcessor constructor\n");
+    PLUGIN_DEBUG("JavaRequestProcessor constructor\n");
 
 	// caller frees this
 	result = new JavaResultData();
@@ -200,7 +200,7 @@
 
 JavaRequestProcessor::~JavaRequestProcessor()
 {
-    PLUGIN_DEBUG_0ARG("JavaRequestProcessor::~JavaRequestProcessor\n");
+    PLUGIN_DEBUG("JavaRequestProcessor::~JavaRequestProcessor\n");
 
 	if (result)
 	{
@@ -271,7 +271,7 @@
     	result->error_msg->append("Error: Timed out when waiting for response");
 
     	// Report error
-    	PLUGIN_DEBUG_1ARG("Error: Timed out when waiting for response to %s\n", message.c_str());
+    	PLUGIN_DEBUG("Error: Timed out when waiting for response to %s\n", message.c_str());
     }
 
     java_to_plugin_bus->unSubscribe(this);
@@ -847,12 +847,12 @@
 
     if (NPVARIANT_IS_VOID(variant))
     {
-    	PLUGIN_DEBUG_1ARG("VOID %d\n", variant);
+    	PLUGIN_DEBUG("VOID %d\n", variant);
     	id->append("0");
     	return; // no need to go further
     } else if (NPVARIANT_IS_NULL(variant))
     {
-    	PLUGIN_DEBUG_1ARG("NULL\n", variant);
+    	PLUGIN_DEBUG("NULL\n", variant);
     	id->append("0");
     	return; // no need to go further
     } else if (NPVARIANT_IS_BOOLEAN(variant))
@@ -894,18 +894,18 @@
         NPObject* obj = NPVARIANT_TO_OBJECT(variant);
         if (IcedTeaScriptableJavaPackageObject::is_valid_java_object(obj))
         {
-            PLUGIN_DEBUG_0ARG("NPObject is a Java object\n");
+            PLUGIN_DEBUG("NPObject is a Java object\n");
             alreadyCreated = true;
         } else
         {
-            PLUGIN_DEBUG_0ARG("NPObject is not a Java object\n");
+            PLUGIN_DEBUG("NPObject is not a Java object\n");
             NPIdentifier length_id = browser_functions.getstringidentifier("length");
 
             // FIXME: We currently only handle <= 2 dim arrays. Do we really need more though?
 
             // Is it an array?
             if (IcedTeaPluginUtilities::isObjectJSArray(instance, obj)) {
-                PLUGIN_DEBUG_0ARG("NPObject is an array\n");
+                PLUGIN_DEBUG("NPObject is an array\n");
 
                 std::string array_id = std::string();
                 std::string java_array_type = std::string();
diff -r d1ad52447673 plugin/icedteanp/IcedTeaNPPlugin.cc
--- a/plugin/icedteanp/IcedTeaNPPlugin.cc	Wed Apr 14 12:21:30 2010 +0200
+++ b/plugin/icedteanp/IcedTeaNPPlugin.cc	Tue Jul 20 16:36:52 2010 +0200
@@ -262,7 +262,7 @@
          int16_t argc, char* argn[], char* argv[],
          NPSavedData* saved)
 {
-  PLUGIN_DEBUG_0ARG("ITNP_New\n");
+  PLUGIN_DEBUG("ITNP_New\n");
 
   static NPObject *window_ptr;
   NPIdentifier identifier;
@@ -275,7 +275,7 @@
   }
   browser_functions.getproperty(instance, window_ptr, identifier, &member_ptr);
 
-  PLUGIN_DEBUG_1ARG("Got variant %p\n", &member_ptr);
+  PLUGIN_DEBUG("Got variant %p\n", &member_ptr);
 
 
   NPError np_error = NPERR_NO_ERROR;
@@ -395,12 +395,12 @@
   documentbase = NULL;
 
   // store an identifier for this plugin
-  PLUGIN_DEBUG_2ARG("Mapping id %d and instance %p\n", instance_counter, instance);
+  PLUGIN_DEBUG("Mapping id %d and instance %p\n", instance_counter, instance);
   g_hash_table_insert(instance_to_id_map, instance, GINT_TO_POINTER(instance_counter));
   g_hash_table_insert(id_to_instance_map, GINT_TO_POINTER(instance_counter), instance);
   instance_counter++;
 
-  PLUGIN_DEBUG_0ARG ("ITNP_New return\n");
+  PLUGIN_DEBUG ("ITNP_New return\n");
 
   return np_error;
 }
@@ -415,16 +415,16 @@
   GMutex *vm_start_mutex = g_mutex_new();
   g_mutex_lock(vm_start_mutex);
 
-  PLUGIN_DEBUG_0ARG("Checking JVM status...\n");
+  PLUGIN_DEBUG("Checking JVM status...\n");
 
   // If the jvm is already up, do nothing
   if (jvm_up)
   {
-      PLUGIN_DEBUG_0ARG("JVM is up. Returning.\n");
+      PLUGIN_DEBUG("JVM is up. Returning.\n");
       return;
   }
 
-  PLUGIN_DEBUG_0ARG("No JVM is running. Attempting to start one...\n");
+  PLUGIN_DEBUG("No JVM is running. Attempting to start one...\n");
 
   NPError np_error = NPERR_NO_ERROR;
   ITNPPluginData* data = NULL;
@@ -447,14 +447,14 @@
   // clean up any older pip
   unlink (in_pipe_name);
 
-  PLUGIN_DEBUG_1ARG ("ITNP_New: creating input fifo: %s\n", in_pipe_name);
+  PLUGIN_DEBUG ("ITNP_New: creating input fifo: %s\n", in_pipe_name);
   if (mkfifo (in_pipe_name, 0600) == -1 && errno != EEXIST)
     {
       PLUGIN_ERROR_TWO ("Failed to create input pipe", strerror (errno));
       np_error = NPERR_GENERIC_ERROR;
       goto cleanup_in_pipe_name;
     }
-  PLUGIN_DEBUG_1ARG ("ITNP_New: created input fifo: %s\n", in_pipe_name);
+  PLUGIN_DEBUG ("ITNP_New: created input fifo: %s\n", in_pipe_name);
 
   // Create plugin-to-appletviewer pipe which we refer to as the
   // output pipe.
@@ -473,14 +473,14 @@
   // clean up any older pip
   unlink (out_pipe_name);
 
-  PLUGIN_DEBUG_1ARG ("ITNP_New: creating output fifo: %s\n", out_pipe_name);
+  PLUGIN_DEBUG ("ITNP_New: creating output fifo: %s\n", out_pipe_name);
   if (mkfifo (out_pipe_name, 0600) == -1 && errno != EEXIST)
     {
       PLUGIN_ERROR_TWO ("Failed to create output pipe", strerror (errno));
       np_error = NPERR_GENERIC_ERROR;
       goto cleanup_out_pipe_name;
     }
-  PLUGIN_DEBUG_1ARG ("ITNP_New: created output fifo: %s\n", out_pipe_name);
+  PLUGIN_DEBUG ("ITNP_New: created output fifo: %s\n", out_pipe_name);
 
   // Start a separate appletviewer process for each applet, even if
   // there are multiple applets in the same page.  We may need to
@@ -571,9 +571,9 @@
 
   // cleanup_out_pipe:
   // Delete output pipe.
-  PLUGIN_DEBUG_1ARG ("ITNP_New: deleting input fifo: %s\n", in_pipe_name);
+  PLUGIN_DEBUG ("ITNP_New: deleting input fifo: %s\n", in_pipe_name);
   unlink (out_pipe_name);
-  PLUGIN_DEBUG_1ARG ("ITNP_New: deleted input fifo: %s\n", in_pipe_name);
+  PLUGIN_DEBUG ("ITNP_New: deleted input fifo: %s\n", in_pipe_name);
 
  cleanup_out_pipe_name:
   g_free (out_pipe_name);
@@ -581,9 +581,9 @@
 
   // cleanup_in_pipe:
   // Delete input pipe.
-  PLUGIN_DEBUG_1ARG ("ITNP_New: deleting output fifo: %s\n", out_pipe_name);
+  PLUGIN_DEBUG ("ITNP_New: deleting output fifo: %s\n", out_pipe_name);
   unlink (in_pipe_name);
-  PLUGIN_DEBUG_1ARG ("ITNP_New: deleted output fifo: %s\n", out_pipe_name);
+  PLUGIN_DEBUG ("ITNP_New: deleted output fifo: %s\n", out_pipe_name);
 
  cleanup_in_pipe_name:
   g_free (in_pipe_name);
@@ -599,7 +599,7 @@
 NPError
 ITNP_GetValue (NPP instance, NPPVariable variable, void* value)
 {
-  PLUGIN_DEBUG_0ARG ("ITNP_GetValue\n");
+  PLUGIN_DEBUG ("ITNP_GetValue\n");
 
   NPError np_error = NPERR_NO_ERROR;
 
@@ -608,7 +608,7 @@
     // This plugin needs XEmbed support.
     case NPPVpluginNeedsXEmbed:
       {
-        PLUGIN_DEBUG_0ARG ("ITNP_GetValue: returning TRUE for NeedsXEmbed.\n");
+        PLUGIN_DEBUG ("ITNP_GetValue: returning TRUE for NeedsXEmbed.\n");
         bool* bool_value = (bool*) value;
         *bool_value = true;
       }
@@ -624,7 +624,7 @@
       break;
     }
 
-  PLUGIN_DEBUG_0ARG ("ITNP_GetValue return\n");
+  PLUGIN_DEBUG ("ITNP_GetValue return\n");
 
   return np_error;
 }
@@ -632,7 +632,7 @@
 NPError
 ITNP_Destroy (NPP instance, NPSavedData** save)
 {
-  PLUGIN_DEBUG_1ARG ("ITNP_Destroy %p\n", instance);
+  PLUGIN_DEBUG ("ITNP_Destroy %p\n", instance);
 
   ITNPPluginData* data = (ITNPPluginData*) instance->pdata;
 
@@ -649,7 +649,7 @@
 
   IcedTeaPluginUtilities::invalidateInstance(instance);
 
-  PLUGIN_DEBUG_0ARG ("ITNP_Destroy return\n");
+  PLUGIN_DEBUG ("ITNP_Destroy return\n");
 
   return NPERR_NO_ERROR;
 }
@@ -657,7 +657,7 @@
 NPError
 ITNP_SetWindow (NPP instance, NPWindow* window)
 {
-  PLUGIN_DEBUG_0ARG ("ITNP_SetWindow\n");
+  PLUGIN_DEBUG ("ITNP_SetWindow\n");
 
   if (instance == NULL)
     {
@@ -679,7 +679,7 @@
   // Simply return if we receive a NULL window.
   if ((window == NULL) || (window->window == NULL))
     {
-      PLUGIN_DEBUG_0ARG ("ITNP_SetWindow: got NULL window.\n");
+      PLUGIN_DEBUG ("ITNP_SetWindow: got NULL window.\n");
 
       return NPERR_NO_ERROR;
     }
@@ -690,7 +690,7 @@
       if (data->window_handle == window->window)
     {
           // The parent window is the same as in previous calls.
-          PLUGIN_DEBUG_0ARG ("ITNP_SetWindow: window already exists.\n");
+          PLUGIN_DEBUG ("ITNP_SetWindow: window already exists.\n");
 
           // Critical region.  Read data->appletviewer_mutex and send
           // a message to the appletviewer.
@@ -704,7 +704,7 @@
           // SetWindow call.
           if (window->width != data->window_width)
         {
-                  PLUGIN_DEBUG_0ARG ("ITNP_SetWindow: window width changed.\n");
+                  PLUGIN_DEBUG ("ITNP_SetWindow: window width changed.\n");
           // The width of the plugin window has changed.
 
                   // Store the new width.
@@ -714,7 +714,7 @@
 
           if (window->height != data->window_height)
         {
-                  PLUGIN_DEBUG_0ARG ("ITNP_SetWindow: window height changed.\n");
+                  PLUGIN_DEBUG ("ITNP_SetWindow: window height changed.\n");
           // The height of the plugin window has changed.
 
                   // Store the new height.
@@ -736,7 +736,7 @@
       else
         {
               // The appletviewer is not running.
-          PLUGIN_DEBUG_0ARG ("ITNP_SetWindow: appletviewer is not running.\n");
+          PLUGIN_DEBUG ("ITNP_SetWindow: appletviewer is not running.\n");
         }
 
           g_mutex_unlock (data->appletviewer_mutex);
@@ -745,12 +745,12 @@
     {
       // The parent window has changed.  This branch does run but
       // doing nothing in response seems to be sufficient.
-      PLUGIN_DEBUG_0ARG ("ITNP_SetWindow: parent window changed.\n");
+      PLUGIN_DEBUG ("ITNP_SetWindow: parent window changed.\n");
     }
     }
   else
     {
-      PLUGIN_DEBUG_0ARG ("ITNP_SetWindow: setting window.\n");
+      PLUGIN_DEBUG ("ITNP_SetWindow: setting window.\n");
 
       // Critical region.  Send messages to appletviewer.
       g_mutex_lock (data->appletviewer_mutex);
@@ -774,7 +774,7 @@
       data->window_handle = window->window;
     }
 
-  PLUGIN_DEBUG_0ARG ("ITNP_SetWindow return\n");
+  PLUGIN_DEBUG ("ITNP_SetWindow return\n");
 
   return NPERR_NO_ERROR;
 }
@@ -783,9 +783,9 @@
 ITNP_NewStream (NPP instance, NPMIMEType type, NPStream* stream,
                NPBool seekable, uint16_t* stype)
 {
-  PLUGIN_DEBUG_0ARG ("ITNP_NewStream\n");
+  PLUGIN_DEBUG ("ITNP_NewStream\n");
 
-  PLUGIN_DEBUG_0ARG ("ITNP_NewStream return\n");
+  PLUGIN_DEBUG ("ITNP_NewStream return\n");
 
   return NPERR_NO_ERROR;
 }
@@ -793,17 +793,17 @@
 void
 ITNP_StreamAsFile (NPP instance, NPStream* stream, const char* filename)
 {
-  PLUGIN_DEBUG_0ARG ("ITNP_StreamAsFile\n");
+  PLUGIN_DEBUG ("ITNP_StreamAsFile\n");
 
-  PLUGIN_DEBUG_0ARG ("ITNP_StreamAsFile return\n");
+  PLUGIN_DEBUG ("ITNP_StreamAsFile return\n");
 }
 
 NPError
 ITNP_DestroyStream (NPP instance, NPStream* stream, NPReason reason)
 {
-  PLUGIN_DEBUG_0ARG ("ITNP_DestroyStream\n");
+  PLUGIN_DEBUG ("ITNP_DestroyStream\n");
 
-  PLUGIN_DEBUG_0ARG ("ITNP_DestroyStream return\n");
+  PLUGIN_DEBUG ("ITNP_DestroyStream return\n");
 
   return NPERR_NO_ERROR;
 }
@@ -811,9 +811,9 @@
 int32_t
 ITNP_WriteReady (NPP instance, NPStream* stream)
 {
-  PLUGIN_DEBUG_0ARG ("ITNP_WriteReady\n");
+  PLUGIN_DEBUG ("ITNP_WriteReady\n");
 
-  PLUGIN_DEBUG_0ARG ("ITNP_WriteReady return\n");
+  PLUGIN_DEBUG ("ITNP_WriteReady return\n");
 
   return 0;
 }
@@ -822,9 +822,9 @@
 ITNP_Write (NPP instance, NPStream* stream, int32_t offset, int32_t len,
            void* buffer)
 {
-  PLUGIN_DEBUG_0ARG ("ITNP_Write\n");
+  PLUGIN_DEBUG ("ITNP_Write\n");
 
-  PLUGIN_DEBUG_0ARG ("ITNP_Write return\n");
+  PLUGIN_DEBUG ("ITNP_Write return\n");
 
   return 0;
 }
@@ -832,17 +832,17 @@
 void
 ITNP_Print (NPP instance, NPPrint* platformPrint)
 {
-  PLUGIN_DEBUG_0ARG ("ITNP_Print\n");
+  PLUGIN_DEBUG ("ITNP_Print\n");
 
-  PLUGIN_DEBUG_0ARG ("ITNP_Print return\n");
+  PLUGIN_DEBUG ("ITNP_Print return\n");
 }
 
 int16_t
 ITNP_HandleEvent (NPP instance, void* event)
 {
-  PLUGIN_DEBUG_0ARG ("ITNP_HandleEvent\n");
+  PLUGIN_DEBUG ("ITNP_HandleEvent\n");
 
-  PLUGIN_DEBUG_0ARG ("ITNP_HandleEvent return\n");
+  PLUGIN_DEBUG ("ITNP_HandleEvent return\n");
 
   return 0;
 }
@@ -851,9 +851,9 @@
 ITNP_URLNotify (NPP instance, const char* url, NPReason reason,
                void* notifyData)
 {
-  PLUGIN_DEBUG_0ARG ("ITNP_URLNotify\n");
+  PLUGIN_DEBUG ("ITNP_URLNotify\n");
 
-  PLUGIN_DEBUG_0ARG ("ITNP_URLNotify return\n");
+  PLUGIN_DEBUG ("ITNP_URLNotify return\n");
 }
 
 NPError
@@ -924,7 +924,7 @@
 static void
 plugin_data_new (ITNPPluginData** data)
 {
-  PLUGIN_DEBUG_0ARG ("plugin_data_new\n");
+  PLUGIN_DEBUG ("plugin_data_new\n");
 
   *data = (ITNPPluginData*)
     (*browser_functions.memalloc) (sizeof (struct ITNPPluginData));
@@ -933,7 +933,7 @@
   if (*data)
     memset (*data, 0, sizeof (struct ITNPPluginData));
 
-  PLUGIN_DEBUG_0ARG ("plugin_data_new return\n");
+  PLUGIN_DEBUG ("plugin_data_new return\n");
 }
 
 
@@ -948,7 +948,7 @@
 static gchar*
 plugin_get_documentbase (NPP instance)
 {
-  PLUGIN_DEBUG_0ARG ("plugin_get_documentbase\n");
+  PLUGIN_DEBUG ("plugin_get_documentbase\n");
 
   nsIPluginInstance* xpcom_instance = NULL;
   nsIPluginInstancePeer* peer = NULL;
@@ -1000,16 +1000,16 @@
   NS_RELEASE (peer);
 
  cleanup_done:
-  PLUGIN_DEBUG_0ARG ("plugin_get_documentbase return\n");
+  PLUGIN_DEBUG ("plugin_get_documentbase return\n");
 
-  PLUGIN_DEBUG_1ARG("plugin_get_documentbase returning: %s\n", documentbase_copy);
+  PLUGIN_DEBUG("plugin_get_documentbase returning: %s\n", documentbase_copy);
   return documentbase_copy;
 }
 #else
 static gchar*
 plugin_get_documentbase (NPP instance)
 {
-  PLUGIN_DEBUG_0ARG ("plugin_get_documentbase\n");
+  PLUGIN_DEBUG ("plugin_get_documentbase\n");
 
   char const* documentbase = NULL;
   gchar* documentbase_copy = NULL;
@@ -1021,30 +1021,26 @@
   // Additionally, since it is insecure, we cannot use it for making
   // security decisions.
   NPObject* window;
-  NPString script = NPString();
-  std::string script_str = std::string();
-  NPVariant* location = new NPVariant();
-  std::string location_str = std::string();
+  browser_functions.getvalue(instance, NPNVWindowNPObject, &window);
 
-  browser_functions.getvalue(instance, NPNVWindowNPObject, &window);
-  script_str += "window.location.href";
-#if MOZILLA_VERSION_COLLAPSED < 1090200
-  script.utf8characters = script_str.c_str();
-  script.utf8length = script_str.size();
-#else
-  script.UTF8Characters = script_str.c_str();
-  script.UTF8Length = script_str.size();
-#endif
-  browser_functions.evaluate(instance, window, &script, location);
+  NPVariant location;
+  NPIdentifier location_id = browser_functions.getstringidentifier("location");
+  browser_functions.getproperty(instance, window, location_id, &location);
+
+  NPVariant href;
+  NPIdentifier href_id = browser_functions.getstringidentifier("href");
+  browser_functions.getproperty(instance, NPVARIANT_TO_OBJECT(location), 
+                               href_id, &href);
 
   // Strip everything after the last "/"
 #if MOZILLA_VERSION_COLLAPSED < 1090200
-  gchar** parts = g_strsplit (NPVARIANT_TO_STRING(*location).utf8characters, "/", -1);
+  gchar** parts = g_strsplit (NPVARIANT_TO_STRING(href).utf8characters, "/", -1);
 #else
-  gchar** parts = g_strsplit (NPVARIANT_TO_STRING(*location).UTF8Characters, "/", -1);
+  gchar** parts = g_strsplit (NPVARIANT_TO_STRING(href).UTF8Characters, "/", -1);
 #endif
   guint parts_sz = g_strv_length (parts);
 
+  std::string location_str;
   for (int i=0; i < parts_sz - 1; i++)
   {
       location_str += parts[i];
@@ -1054,9 +1050,11 @@
   documentbase_copy = g_strdup (location_str.c_str());
 
   // Release references.
+  browser_functions.releasevariantvalue(&href);
+  browser_functions.releasevariantvalue(&location);
  cleanup_done:
-  PLUGIN_DEBUG_0ARG ("plugin_get_documentbase return\n");
-  PLUGIN_DEBUG_1ARG("plugin_get_documentbase returning: %s\n", documentbase_copy);
+  PLUGIN_DEBUG ("plugin_get_documentbase return\n");
+  PLUGIN_DEBUG("plugin_get_documentbase returning: %s\n", documentbase_copy);
 
   return documentbase_copy;
 }
@@ -1069,7 +1067,7 @@
 {
   GtkWidget* dialog = NULL;
 
-  PLUGIN_DEBUG_0ARG ("plugin_display_failure_dialog\n");
+  PLUGIN_DEBUG ("plugin_display_failure_dialog\n");
 
   dialog = gtk_message_dialog_new (NULL,
                                    GTK_DIALOG_DESTROY_WITH_PARENT,
@@ -1081,7 +1079,7 @@
   gtk_dialog_run (GTK_DIALOG (dialog));
   gtk_widget_destroy (dialog);
 
-  PLUGIN_DEBUG_0ARG ("plugin_display_failure_dialog return\n");
+  PLUGIN_DEBUG ("plugin_display_failure_dialog return\n");
 }
 
 
@@ -1095,7 +1093,7 @@
                          GIOCondition condition,
                          gpointer plugin_data)
 {
-  PLUGIN_DEBUG_0ARG ("plugin_in_pipe_callback\n");
+  PLUGIN_DEBUG ("plugin_in_pipe_callback\n");
 
   gboolean keep_installed = TRUE;
 
@@ -1130,18 +1128,18 @@
 
   if (condition & (G_IO_ERR | G_IO_HUP))
     {
-      PLUGIN_DEBUG_0ARG ("appletviewer has stopped.\n");
+      PLUGIN_DEBUG ("appletviewer has stopped.\n");
       keep_installed = FALSE;
     }
 
-  PLUGIN_DEBUG_0ARG ("plugin_in_pipe_callback return\n");
+  PLUGIN_DEBUG ("plugin_in_pipe_callback return\n");
 
   return keep_installed;
 }
 
 void consume_message(gchar* message) {
 
-	PLUGIN_DEBUG_1ARG ("  PIPE: plugin read: %s\n", message);
+	PLUGIN_DEBUG ("  PIPE: plugin read: %s\n", message);
 
   if (g_str_has_prefix (message, "instance"))
     {
@@ -1156,7 +1154,7 @@
 
       if (instance_id > 0 && !instance)
         {
-          PLUGIN_DEBUG_2ARG("Instance %d is not active. Refusing to consume message \"%s\"\n", instance_id, message);
+          PLUGIN_DEBUG("Instance %d is not active. Refusing to consume message \"%s\"\n", instance_id, message);
           return;
         }
       else if (instance)
@@ -1170,8 +1168,8 @@
           gchar* decoded_url = (gchar*) calloc(strlen(parts[3]) + 1, sizeof(gchar));
           IcedTeaPluginUtilities::decodeURL(parts[3], &decoded_url);
 
-          PLUGIN_DEBUG_1ARG ("plugin_in_pipe_callback: opening URL %s\n", decoded_url);
-          PLUGIN_DEBUG_1ARG ("plugin_in_pipe_callback: URL target %s\n", parts[4]);
+          PLUGIN_DEBUG ("plugin_in_pipe_callback: opening URL %s\n", decoded_url);
+          PLUGIN_DEBUG ("plugin_in_pipe_callback: URL target %s\n", parts[4]);
 
           NPError np_error =
             (*browser_functions.geturl) (data->owner, decoded_url, parts[4]);
@@ -1193,7 +1191,7 @@
 
           // join the rest
           gchar* status_message = g_strjoinv(" ", parts);
-          PLUGIN_DEBUG_1ARG ("plugin_in_pipe_callback: setting status %s\n", status_message);
+          PLUGIN_DEBUG ("plugin_in_pipe_callback: setting status %s\n", status_message);
           (*browser_functions.status) (data->owner, status_message);
 
           g_free(status_message);
@@ -1229,7 +1227,7 @@
 
         gchar* decoded_url = (gchar*) calloc(strlen(parts[4]) + 1, sizeof(gchar));
         IcedTeaPluginUtilities::decodeURL(parts[4], &decoded_url);
-        PLUGIN_DEBUG_5ARG("parts[0]=%s, parts[1]=%s, reference, parts[3]=%s, parts[4]=%s -- decoded_url=%s\n", parts[0], parts[1], parts[3], parts[4], decoded_url);
+        PLUGIN_DEBUG("parts[0]=%s, parts[1]=%s, reference, parts[3]=%s, parts[4]=%s -- decoded_url=%s\n", parts[0], parts[1], parts[3], parts[4], decoded_url);
 
         gchar* proxy_info;
 
@@ -1243,7 +1241,7 @@
             proxy_info = g_strconcat (proxy_info, proxy, NULL);
           }
 
-        PLUGIN_DEBUG_1ARG("Proxy info: %s\n", proxy_info);
+        PLUGIN_DEBUG("Proxy info: %s\n", proxy_info);
         plugin_send_message_to_appletviewer(proxy_info);
 
         g_free(decoded_url);
@@ -1269,7 +1267,7 @@
             cookie_info = g_strconcat (cookie_info, cookie_string, NULL);
         }
 
-        PLUGIN_DEBUG_1ARG("Cookie info: %s\n", cookie_info);
+        PLUGIN_DEBUG("Cookie info: %s\n", cookie_info);
         plugin_send_message_to_appletviewer(cookie_info);
 
         g_free(decoded_url);
@@ -1294,7 +1292,7 @@
 {
     int id = GPOINTER_TO_INT(g_hash_table_lookup(instance_to_id_map,
                                                        instance));
-    PLUGIN_DEBUG_2ARG("Returning id %d for instance %p\n", id, instance);
+    PLUGIN_DEBUG("Returning id %d for instance %p\n", id, instance);
     return id;
 }
 
@@ -1329,7 +1327,7 @@
 
   // if there is no proxy found, return immediately
   if (!info) {
-     PLUGIN_DEBUG_1ARG("%s does not need a proxy\n", siteAddr);
+     PLUGIN_DEBUG("%s does not need a proxy\n", siteAddr);
      return NPERR_GENERIC_ERROR;
   }
 
@@ -1367,7 +1365,7 @@
 
   *len = strlen(*proxy);
 
-  PLUGIN_DEBUG_2ARG("Proxy info for %s: %s\n", siteAddr, *proxy);
+  PLUGIN_DEBUG("Proxy info for %s: %s\n", siteAddr, *proxy);
 
 #else
 
@@ -1400,13 +1398,13 @@
                           GIOCondition condition,
                           gpointer plugin_data)
 {
-  PLUGIN_DEBUG_0ARG ("plugin_out_pipe_callback\n");
+  PLUGIN_DEBUG ("plugin_out_pipe_callback\n");
 
   ITNPPluginData* data = (ITNPPluginData*) plugin_data;
 
-  PLUGIN_DEBUG_0ARG ("plugin_out_pipe_callback: appletviewer has stopped.\n");
+  PLUGIN_DEBUG ("plugin_out_pipe_callback: appletviewer has stopped.\n");
 
-  PLUGIN_DEBUG_0ARG ("plugin_out_pipe_callback return\n");
+  PLUGIN_DEBUG ("plugin_out_pipe_callback return\n");
 
   return FALSE;
 }
@@ -1449,12 +1447,12 @@
 
   if (path_new == NULL || strlen (path_new) == 0)
     {
-      PLUGIN_DEBUG_0ARG("Unset LD_LIBRARY_PATH\n");
+      PLUGIN_DEBUG("Unset LD_LIBRARY_PATH\n");
       return NULL;
     }
   else
     {
-      PLUGIN_DEBUG_1ARG ("Set LD_LIBRARY_PATH: %s\n", path_new);
+      PLUGIN_DEBUG ("Set LD_LIBRARY_PATH: %s\n", path_new);
       return path_new;
     }
 }
@@ -1464,7 +1462,7 @@
 plugin_filter_environment(void)
 {
   gchar **var_names = g_listenv();
-  gchar **new_env = (gchar**) malloc(sizeof(gchar*) * g_strv_length (var_names));
+  gchar **new_env = (gchar**) malloc(sizeof(gchar*) * (g_strv_length (var_names) + 1));
   int i_var, i_env;
 
   for (i_var = 0, i_env = 0; var_names[i_var] != NULL; i_var++)
@@ -1486,7 +1484,7 @@
 static NPError
 plugin_test_appletviewer ()
 {
-  PLUGIN_DEBUG_1ARG ("plugin_test_appletviewer: %s\n", appletviewer_executable);
+  PLUGIN_DEBUG ("plugin_test_appletviewer: %s\n", appletviewer_executable);
   NPError error = NPERR_NO_ERROR;
 
   gchar* command_line[3] = { NULL, NULL, NULL };
@@ -1523,14 +1521,14 @@
   g_free (command_line[2]);
   command_line[2] = NULL;
 
-  PLUGIN_DEBUG_0ARG ("plugin_test_appletviewer return\n");
+  PLUGIN_DEBUG ("plugin_test_appletviewer return\n");
   return error;
 }
 
 static NPError
 plugin_start_appletviewer (ITNPPluginData* data)
 {
-  PLUGIN_DEBUG_0ARG ("plugin_start_appletviewer\n");
+  PLUGIN_DEBUG ("plugin_start_appletviewer\n");
   NPError error = NPERR_NO_ERROR;
 
   gchar** command_line;
@@ -1599,12 +1597,12 @@
 
   if (appletviewer_pid)
     {
-      PLUGIN_DEBUG_1ARG("Initialized VM with pid=%d\n", appletviewer_pid);
+      PLUGIN_DEBUG("Initialized VM with pid=%d\n", appletviewer_pid);
       appletviewer_watch_id = g_child_watch_add(appletviewer_pid, (GChildWatchFunc) appletviewer_monitor, (gpointer) appletviewer_pid);
     }
 
 
-  PLUGIN_DEBUG_0ARG ("plugin_start_appletviewer return\n");
+  PLUGIN_DEBUG ("plugin_start_appletviewer return\n");
   return error;
 }
 
@@ -1613,7 +1611,7 @@
 static gchar*
 plugin_create_applet_tag (int16_t argc, char* argn[], char* argv[])
 {
-  PLUGIN_DEBUG_0ARG ("plugin_create_applet_tag\n");
+  PLUGIN_DEBUG ("plugin_create_applet_tag\n");
 
   gchar* applet_tag = g_strdup ("<EMBED ");
   gchar* parameters = g_strdup ("");
@@ -1712,7 +1710,7 @@
   g_free (parameters);
   parameters = NULL;
 
-  PLUGIN_DEBUG_0ARG ("plugin_create_applet_tag return\n");
+  PLUGIN_DEBUG ("plugin_create_applet_tag return\n");
 
   return applet_tag;
 }
@@ -1722,7 +1720,7 @@
 void
 plugin_send_message_to_appletviewer (gchar const* message)
 {
-  PLUGIN_DEBUG_0ARG ("plugin_send_message_to_appletviewer\n");
+  PLUGIN_DEBUG ("plugin_send_message_to_appletviewer\n");
 
   if (jvm_up)
     {
@@ -1767,10 +1765,10 @@
       g_free (newline_message);
       newline_message = NULL;
 
-      PLUGIN_DEBUG_1ARG ("  PIPE: plugin wrote: %s\n", message);
+      PLUGIN_DEBUG ("  PIPE: plugin wrote: %s\n", message);
     }
 
-  PLUGIN_DEBUG_0ARG ("plugin_send_message_to_appletviewer return\n");
+  PLUGIN_DEBUG ("plugin_send_message_to_appletviewer return\n");
 }
 
 // Stop the appletviewer process.  When this is called the
@@ -1789,7 +1787,7 @@
 static void
 plugin_stop_appletviewer ()
 {
-  PLUGIN_DEBUG_0ARG ("plugin_stop_appletviewer\n");
+  PLUGIN_DEBUG ("plugin_stop_appletviewer\n");
 
   if (jvm_up)
     {
@@ -1865,21 +1863,21 @@
   jvm_up = FALSE;
   sleep(2); /* Needed to prevent crashes during debug (when JDWP port is not freed by the kernel right away) */
 
-  PLUGIN_DEBUG_0ARG ("plugin_stop_appletviewer return\n");
+  PLUGIN_DEBUG ("plugin_stop_appletviewer return\n");
 }
 
 static void appletviewer_monitor(GPid pid, gint status, gpointer data)
 {
-    PLUGIN_DEBUG_0ARG ("appletviewer_monitor\n");
+    PLUGIN_DEBUG ("appletviewer_monitor\n");
     jvm_up = FALSE;
     pid = -1;
-    PLUGIN_DEBUG_0ARG ("appletviewer_monitor return\n");
+    PLUGIN_DEBUG ("appletviewer_monitor return\n");
 }
 
 static void
 plugin_data_destroy (NPP instance)
 {
-  PLUGIN_DEBUG_0ARG ("plugin_data_destroy\n");
+  PLUGIN_DEBUG ("plugin_data_destroy\n");
 
   ITNPPluginData* tofree = (ITNPPluginData*) instance->pdata;
 
@@ -1914,7 +1912,7 @@
   (*browser_functions.memfree) (tofree);
   tofree = NULL;
 
-  PLUGIN_DEBUG_0ARG ("plugin_data_destroy return\n");
+  PLUGIN_DEBUG ("plugin_data_destroy return\n");
 }
 
 // FACTORY FUNCTIONS
@@ -1931,7 +1929,7 @@
 NPError
 NP_Initialize (NPNetscapeFuncs* browserTable, NPPluginFuncs* pluginTable)
 {
-  PLUGIN_DEBUG_0ARG ("NP_Initialize\n");
+  PLUGIN_DEBUG ("NP_Initialize\n");
 
   if (initialized)
     return NPERR_NO_ERROR;
@@ -2145,7 +2143,7 @@
 
   appletviewer_executable = g_strdup_printf ("%s/../../bin/java",
                                              dirname (filename));
-  PLUGIN_DEBUG_4ARG(".so is located at: %s and the link points to: %s. Executing java from dir %s to run %s\n", info.dli_fname, filename, dirname (filename), appletviewer_executable);
+  PLUGIN_DEBUG(".so is located at: %s and the link points to: %s. Executing java from dir %s to run %s\n", info.dli_fname, filename, dirname (filename), appletviewer_executable);
   if (!appletviewer_executable)
     {
       PLUGIN_ERROR ("Failed to create appletviewer executable name.");
@@ -2169,9 +2167,9 @@
 
   plugin_instance_mutex = g_mutex_new ();
 
-  PLUGIN_DEBUG_1ARG ("NP_Initialize: using %s\n", appletviewer_executable);
+  PLUGIN_DEBUG ("NP_Initialize: using %s\n", appletviewer_executable);
 
-  PLUGIN_DEBUG_0ARG ("NP_Initialize return\n");
+  PLUGIN_DEBUG ("NP_Initialize return\n");
 
   plugin_req_proc = new PluginRequestProcessor();
   java_req_proc = new JavaMessageSender();
@@ -2218,9 +2216,9 @@
 char*
 NP_GetMIMEDescription ()
 {
-  PLUGIN_DEBUG_0ARG ("NP_GetMIMEDescription\n");
+  PLUGIN_DEBUG ("NP_GetMIMEDescription\n");
 
-  PLUGIN_DEBUG_0ARG ("NP_GetMIMEDescription return\n");
+  PLUGIN_DEBUG ("NP_GetMIMEDescription return\n");
 
   return (char*) PLUGIN_MIME_DESC;
 }
@@ -2230,7 +2228,7 @@
 NPError
 NP_GetValue (void* future, NPPVariable variable, void* value)
 {
-  PLUGIN_DEBUG_0ARG ("NP_GetValue\n");
+  PLUGIN_DEBUG ("NP_GetValue\n");
 
   NPError result = NPERR_NO_ERROR;
   gchar** char_value = (gchar**) value;
@@ -2238,12 +2236,12 @@
   switch (variable)
     {
     case NPPVpluginNameString:
-      PLUGIN_DEBUG_0ARG ("NP_GetValue: returning plugin name.\n");
+      PLUGIN_DEBUG ("NP_GetValue: returning plugin name.\n");
       *char_value = g_strdup (PLUGIN_NAME);
       break;
 
     case NPPVpluginDescriptionString:
-      PLUGIN_DEBUG_0ARG ("NP_GetValue: returning plugin description.\n");
+      PLUGIN_DEBUG ("NP_GetValue: returning plugin description.\n");
       *char_value = g_strdup (PLUGIN_DESC);
       break;
 
@@ -2253,7 +2251,7 @@
       break;
     }
 
-  PLUGIN_DEBUG_0ARG ("NP_GetValue return\n");
+  PLUGIN_DEBUG ("NP_GetValue return\n");
 
   return result;
 }
@@ -2263,7 +2261,7 @@
 NPError
 NP_Shutdown (void)
 {
-  PLUGIN_DEBUG_0ARG ("NP_Shutdown\n");
+  PLUGIN_DEBUG ("NP_Shutdown\n");
 
   // Free mutex.
   if (plugin_instance_mutex)
@@ -2312,9 +2310,9 @@
 
   // cleanup_out_pipe:
   // Delete output pipe.
-  PLUGIN_DEBUG_1ARG ("NP_Shutdown: deleting output fifo: %s\n", out_pipe_name);
+  PLUGIN_DEBUG ("NP_Shutdown: deleting output fifo: %s\n", out_pipe_name);
   unlink (out_pipe_name);
-  PLUGIN_DEBUG_1ARG ("NP_Shutdown: deleted output fifo: %s\n", out_pipe_name);
+  PLUGIN_DEBUG ("NP_Shutdown: deleted output fifo: %s\n", out_pipe_name);
 
   // cleanup_out_pipe_name:
   g_free (out_pipe_name);
@@ -2322,9 +2320,9 @@
 
   // cleanup_in_pipe:
   // Delete input pipe.
-  PLUGIN_DEBUG_1ARG ("NP_Shutdown: deleting input fifo: %s\n", in_pipe_name);
+  PLUGIN_DEBUG ("NP_Shutdown: deleting input fifo: %s\n", in_pipe_name);
   unlink (in_pipe_name);
-  PLUGIN_DEBUG_1ARG ("NP_Shutdown: deleted input fifo: %s\n", in_pipe_name);
+  PLUGIN_DEBUG ("NP_Shutdown: deleted input fifo: %s\n", in_pipe_name);
 
   // cleanup_in_pipe_name:
   g_free (in_pipe_name);
@@ -2347,7 +2345,7 @@
   delete plugin_to_java_bus;
   //delete internal_bus;
 
-  PLUGIN_DEBUG_0ARG ("NP_Shutdown return\n");
+  PLUGIN_DEBUG ("NP_Shutdown return\n");
 
   return NPERR_NO_ERROR;
 }
@@ -2415,6 +2413,6 @@
 NPObject*
 allocate_scriptable_object(NPP npp, NPClass *aClass)
 {
-	PLUGIN_DEBUG_0ARG("Allocating new scriptable object\n");
+	PLUGIN_DEBUG("Allocating new scriptable object\n");
 	return new IcedTeaScriptablePluginObject(npp);
 }
diff -r d1ad52447673 plugin/icedteanp/IcedTeaPluginRequestProcessor.cc
--- a/plugin/icedteanp/IcedTeaPluginRequestProcessor.cc	Wed Apr 14 12:21:30 2010 +0200
+++ b/plugin/icedteanp/IcedTeaPluginRequestProcessor.cc	Tue Jul 20 16:36:52 2010 +0200
@@ -73,7 +73,7 @@
 
 PluginRequestProcessor::~PluginRequestProcessor()
 {
-    PLUGIN_DEBUG_0ARG("PluginRequestProcessor::~PluginRequestProcessor\n");
+    PLUGIN_DEBUG("PluginRequestProcessor::~PluginRequestProcessor\n");
 
     if (pendingRequests)
         delete pendingRequests;
@@ -89,7 +89,7 @@
 bool
 PluginRequestProcessor::newMessageOnBus(const char* message)
 {
-    PLUGIN_DEBUG_1ARG("PluginRequestProcessor processing %s\n", message);
+    PLUGIN_DEBUG("PluginRequestProcessor processing %s\n", message);
 
     std::string* type;
     std::string* command;
@@ -169,7 +169,7 @@
     get_instance_from_id(id, instance);
 
     browser_functions.getvalue(instance, NPNVWindowNPObject, &window_ptr);
-    PLUGIN_DEBUG_3ARG("ID=%d, Instance=%p, WindowPTR = %p\n", id, instance, window_ptr);
+    PLUGIN_DEBUG("ID=%d, Instance=%p, WindowPTR = %p\n", id, instance, window_ptr);
 
     OBJECT_TO_NPVARIANT(window_ptr, *variant);
     browser_functions.retainobject(window_ptr);
@@ -592,7 +592,7 @@
     }
 #endif
 
-    PLUGIN_DEBUG_1ARG("Member PTR after internal request: %s\n", thread_data.result.c_str());
+    PLUGIN_DEBUG("Member PTR after internal request: %s\n", thread_data.result.c_str());
 
     java_result = java_request.findClass(0, "netscape.javascript.JSObject");
 
@@ -711,7 +711,7 @@
     std::string command;
     pthread_mutex_t wait_mutex = PTHREAD_MUTEX_INITIALIZER; // This is needed for API compat. and is unused
 
-    PLUGIN_DEBUG_1ARG("Queue processor initialized. Queue = %p\n", message_queue);
+    PLUGIN_DEBUG("Queue processor initialized. Queue = %p\n", message_queue);
 
     while (true)
     {
@@ -787,7 +787,7 @@
         message_parts = NULL;
     }
 
-    PLUGIN_DEBUG_0ARG("Queue processing stopped.\n");
+    PLUGIN_DEBUG("Queue processing stopped.\n");
 }
 
 /******************************************
@@ -810,7 +810,7 @@
     property = (NPIdentifier*) parameters.at(2);
     value = (std::string*) parameters.at(3);
 
-    PLUGIN_DEBUG_4ARG("Setting %s on instance %p, object %p to value %s\n", browser_functions.utf8fromidentifier(*property), instance, member, value->c_str());
+    PLUGIN_DEBUG("Setting %s on instance %p, object %p to value %s\n", browser_functions.utf8fromidentifier(*property), instance, member, value->c_str());
 
     IcedTeaPluginUtilities::javaResultToNPVariant(instance, value, &value_variant);
 
@@ -834,7 +834,7 @@
     NPIdentifier* member_identifier = (NPIdentifier*) parameters.at(2);
 
     // Get the NPVariant corresponding to this member
-    PLUGIN_DEBUG_4ARG("Looking for %p %p %p (%s)\n", instance, parent_ptr, member_identifier, browser_functions.utf8fromidentifier(*member_identifier));
+    PLUGIN_DEBUG("Looking for %p %p %p (%s)\n", instance, parent_ptr, member_identifier, browser_functions.utf8fromidentifier(*member_identifier));
 
     if (!browser_functions.hasproperty(instance, parent_ptr, *member_identifier))
     {
@@ -854,7 +854,7 @@
     // store member -> instance link
     IcedTeaPluginUtilities::storeInstanceID(member_ptr, instance);
 
-    PLUGIN_DEBUG_0ARG("_getMember returning.\n");
+    PLUGIN_DEBUG("_getMember returning.\n");
 }
 
 void
@@ -868,7 +868,7 @@
     NPVariant* eval_result = new NPVariant();
     std::string eval_result_ptr_str = std::string();
 
-    PLUGIN_DEBUG_0ARG("_eval called\n");
+    PLUGIN_DEBUG("_eval called\n");
 
     std::vector<void*>* call_data = (std::vector<void*>*) data;
 
@@ -880,12 +880,12 @@
     script.utf8characters = script_str->c_str();
     script.utf8length = script_str->size();
 
-    PLUGIN_DEBUG_1ARG("Evaluating: %s\n", script.utf8characters);
+    PLUGIN_DEBUG("Evaluating: %s\n", script.utf8characters);
 #else
     script.UTF8Characters = script_str->c_str();
     script.UTF8Length = script_str->size();
 
-    PLUGIN_DEBUG_1ARG("Evaluating: %s\n", script.UTF8Characters);
+    PLUGIN_DEBUG("Evaluating: %s\n", script.UTF8Characters);
 #endif
 
     ((AsyncCallThreadData*) data)->call_successful = browser_functions.evaluate(instance, window_ptr, &script, eval_result);
@@ -898,7 +898,7 @@
     }
     ((AsyncCallThreadData*) data)->result_ready = true;
 
-    PLUGIN_DEBUG_0ARG("_eval returning\n");
+    PLUGIN_DEBUG("_eval returning\n");
 }
 
 
@@ -914,7 +914,7 @@
     NPVariant* call_result = new NPVariant();
     std::string call_result_ptr_str = std::string();
 
-    PLUGIN_DEBUG_0ARG("_call called\n");
+    PLUGIN_DEBUG("_call called\n");
 
     std::vector<void*>* call_data = (std::vector<void*>*) data;
 
@@ -930,7 +930,9 @@
         IcedTeaPluginUtilities::printNPVariant(args[i]);
     }
 
+    PLUGIN_DEBUG("_calling\n");
     ((AsyncCallThreadData*) data)->call_successful = browser_functions.invoke(instance, window_ptr, function, args, *arg_count, call_result);
+    PLUGIN_DEBUG("_called\n");
 
     IcedTeaPluginUtilities::printNPVariant(*call_result);
 
@@ -942,7 +944,7 @@
 
     ((AsyncCallThreadData*) data)->result_ready = true;
 
-    PLUGIN_DEBUG_0ARG("_call returning\n");
+    PLUGIN_DEBUG("_call returning\n");
 }
 
 void
@@ -958,7 +960,7 @@
     instance = (NPP) call_data->at(0);
     NPVariant* variant = (NPVariant*) call_data->at(1);
 
-    PLUGIN_DEBUG_2ARG("_getString called with %p and %p\n", instance, variant);
+    PLUGIN_DEBUG("_getString called with %p and %p\n", instance, variant);
 
     if (NPVARIANT_IS_OBJECT(*variant))
     {
@@ -972,7 +974,7 @@
         ((AsyncCallThreadData*) data)->call_successful = true;
     }
 
-    PLUGIN_DEBUG_0ARG("ToString result: ");
+    PLUGIN_DEBUG("ToString result: ");
     IcedTeaPluginUtilities::printNPVariant(tostring_result);
 
     if (((AsyncCallThreadData*) data)->call_successful)
@@ -981,6 +983,6 @@
     }
     ((AsyncCallThreadData*) data)->result_ready = true;
 
-    PLUGIN_DEBUG_0ARG("_getString returning\n");
+    PLUGIN_DEBUG("_getString returning\n");
 }
 
diff -r d1ad52447673 plugin/icedteanp/IcedTeaPluginUtils.cc
--- a/plugin/icedteanp/IcedTeaPluginUtils.cc	Wed Apr 14 12:21:30 2010 +0200
+++ b/plugin/icedteanp/IcedTeaPluginUtils.cc	Tue Jul 20 16:36:52 2010 +0200
@@ -157,7 +157,7 @@
 
 	result->append(id_str);
 
-	PLUGIN_DEBUG_2ARG("Converting pointer %p to %s\n", id, id_str);
+	PLUGIN_DEBUG("Converting pointer %p to %s\n", id, id_str);
 	free(id_str);
 }
 
@@ -174,15 +174,15 @@
 	void* ptr;
 	if (sizeof(void*) == sizeof(long long))
 	{
-		PLUGIN_DEBUG_2ARG("Casting (long long) \"%s\" -- %llu\n", id_str.c_str(), strtoull(id_str.c_str(), NULL, 0));
+		PLUGIN_DEBUG("Casting (long long) \"%s\" -- %llu\n", id_str.c_str(), strtoull(id_str.c_str(), NULL, 0));
 		ptr = reinterpret_cast <void*> ((unsigned long long) strtoull(id_str.c_str(), NULL, 0));
 	} else
 	{
-		PLUGIN_DEBUG_2ARG("Casting (long) \"%s\" -- %lu\n", id_str.c_str(), strtoul(id_str.c_str(), NULL, 0));
+		PLUGIN_DEBUG("Casting (long) \"%s\" -- %lu\n", id_str.c_str(), strtoul(id_str.c_str(), NULL, 0));
 		ptr = reinterpret_cast <void*> ((unsigned long)  strtoul(id_str.c_str(), NULL, 0));
 	}
 
-	PLUGIN_DEBUG_1ARG("Casted: %p\n", ptr);
+	PLUGIN_DEBUG("Casted: %p\n", ptr);
 
 	return ptr;
 }
@@ -200,15 +200,15 @@
     void* ptr;
     if (sizeof(void*) == sizeof(long long))
     {
-        PLUGIN_DEBUG_2ARG("Casting (long long) \"%s\" -- %llu\n", id_str->c_str(), strtoull(id_str->c_str(), NULL, 0));
+        PLUGIN_DEBUG("Casting (long long) \"%s\" -- %llu\n", id_str->c_str(), strtoull(id_str->c_str(), NULL, 0));
         ptr = reinterpret_cast <void*> ((unsigned long long) strtoull(id_str->c_str(), NULL, 0));
     } else
     {
-        PLUGIN_DEBUG_2ARG("Casting (long) \"%s\" -- %lu\n", id_str->c_str(), strtoul(id_str->c_str(), NULL, 0));
+        PLUGIN_DEBUG("Casting (long) \"%s\" -- %lu\n", id_str->c_str(), strtoul(id_str->c_str(), NULL, 0));
         ptr = reinterpret_cast <void*> ((unsigned long)  strtoul(id_str->c_str(), NULL, 0));
     }
 
-    PLUGIN_DEBUG_1ARG("Casted: %p\n", ptr);
+    PLUGIN_DEBUG("Casted: %p\n", ptr);
 
     return ptr;
 }
@@ -344,7 +344,7 @@
 	for (int i = begin; i < begin+length; i++)
 	    result_unicode_str->push_back((char) strtol(unicode_byte_array->at(i)->c_str(), NULL, 16));
 
-	PLUGIN_DEBUG_2ARG("Converted UTF-8 string: %s. Length=%d\n", result_unicode_str->c_str(), result_unicode_str->length());
+	PLUGIN_DEBUG("Converted UTF-8 string: %s. Length=%d\n", result_unicode_str->c_str(), result_unicode_str->length());
 }
 
 /**
@@ -381,7 +381,7 @@
 	*utf_str = ostream.str();
 
 	free(hex_value);
-	PLUGIN_DEBUG_2ARG("Converted %s to UTF-8 string %s\n", str->c_str(), utf_str->c_str());
+	PLUGIN_DEBUG("Converted %s to UTF-8 string %s\n", str->c_str(), utf_str->c_str());
 }
 
 /**
@@ -451,7 +451,7 @@
 
 	*str += " }";
 
-	PLUGIN_DEBUG_2ARG("%s %s\n", prefix, str->c_str());
+	PLUGIN_DEBUG("%s %s\n", prefix, str->c_str());
 
 	delete str;
 }
@@ -483,7 +483,7 @@
 void
 IcedTeaPluginUtilities::storeInstanceID(void* member_ptr, NPP instance)
 {
-    PLUGIN_DEBUG_2ARG("Storing instance %p with key %p\n", instance, member_ptr);
+    PLUGIN_DEBUG("Storing instance %p with key %p\n", instance, member_ptr);
     instance_map->insert(std::make_pair(member_ptr, instance));
 }
 
@@ -496,7 +496,7 @@
 void
 IcedTeaPluginUtilities::removeInstanceID(void* member_ptr)
 {
-    PLUGIN_DEBUG_1ARG("Removing key %p from instance map\n", member_ptr);
+    PLUGIN_DEBUG("Removing key %p from instance map\n", member_ptr);
     instance_map->erase(member_ptr);
 }
 
@@ -506,7 +506,7 @@
 void
 IcedTeaPluginUtilities::invalidateInstance(NPP instance)
 {
-    PLUGIN_DEBUG_1ARG("Invalidating instance %p\n", instance);
+    PLUGIN_DEBUG("Invalidating instance %p\n", instance);
 
     std::map<void*,NPP>::iterator iterator;
 
@@ -531,14 +531,14 @@
 {
 
     NPP instance = NULL;
-    PLUGIN_DEBUG_1ARG("getInstanceFromMemberPtr looking for %p\n", member_ptr);
+    PLUGIN_DEBUG("getInstanceFromMemberPtr looking for %p\n", member_ptr);
 
     std::map<void*, NPP>::iterator iterator = instance_map->find(member_ptr);
 
     if (iterator != instance_map->end())
     {
         instance = instance_map->find(member_ptr)->second;
-        PLUGIN_DEBUG_2ARG("getInstanceFromMemberPtr found %p. Instance = %p\n", member_ptr, instance);
+        PLUGIN_DEBUG("getInstanceFromMemberPtr found %p. Instance = %p\n", member_ptr, instance);
     }
 
     return instance;
@@ -556,7 +556,7 @@
 {
 
     NPObject* object = NULL;
-    PLUGIN_DEBUG_1ARG("getNPObjectFromJavaKey looking for %s\n", key.c_str());
+    PLUGIN_DEBUG("getNPObjectFromJavaKey looking for %s\n", key.c_str());
 
     std::map<std::string, NPObject*>::iterator iterator = object_map->find(key);
 
@@ -567,7 +567,7 @@
         if (getInstanceFromMemberPtr(mapped_object) != NULL)
         {
             object = mapped_object;
-            PLUGIN_DEBUG_2ARG("getNPObjectFromJavaKey found %s. NPObject = %p\n", key.c_str(), object);
+            PLUGIN_DEBUG("getNPObjectFromJavaKey found %s. NPObject = %p\n", key.c_str(), object);
         }
     }
 
@@ -584,7 +584,7 @@
 void
 IcedTeaPluginUtilities::storeObjectMapping(std::string key, NPObject* object)
 {
-    PLUGIN_DEBUG_2ARG("Storing object %p with key %s\n", object, key.c_str());
+    PLUGIN_DEBUG("Storing object %p with key %s\n", object, key.c_str());
     object_map->insert(std::make_pair(key, object));
 }
 
@@ -597,7 +597,7 @@
 void
 IcedTeaPluginUtilities::removeObjectMapping(std::string key)
 {
-    PLUGIN_DEBUG_1ARG("Removing key %s from object map\n", key.c_str());
+    PLUGIN_DEBUG("Removing key %s from object map\n", key.c_str());
     object_map->erase(key);
 }
 
@@ -627,7 +627,7 @@
 
 	*str += " }";
 
-	PLUGIN_DEBUG_2ARG("%s %s\n", prefix, str->c_str());
+	PLUGIN_DEBUG("%s %s\n", prefix, str->c_str());
 
 	delete str;
 }
@@ -641,35 +641,35 @@
 
     if (NPVARIANT_IS_VOID(variant))
     {
-    	PLUGIN_DEBUG_1ARG("VOID %d\n", variant);
+    	PLUGIN_DEBUG("VOID %d\n", variant);
     }
     else if (NPVARIANT_IS_NULL(variant))
     {
-    	PLUGIN_DEBUG_1ARG("NULL\n", variant);
+    	PLUGIN_DEBUG("NULL\n", variant);
     }
     else if (NPVARIANT_IS_BOOLEAN(variant))
     {
-    	PLUGIN_DEBUG_1ARG("BOOL: %d\n", NPVARIANT_TO_BOOLEAN(variant));
+    	PLUGIN_DEBUG("BOOL: %d\n", NPVARIANT_TO_BOOLEAN(variant));
     }
     else if (NPVARIANT_IS_INT32(variant))
     {
-    	PLUGIN_DEBUG_1ARG("INT32: %d\n", NPVARIANT_TO_INT32(variant));
+    	PLUGIN_DEBUG("INT32: %d\n", NPVARIANT_TO_INT32(variant));
     }
     else if (NPVARIANT_IS_DOUBLE(variant))
     {
-    	PLUGIN_DEBUG_1ARG("DOUBLE: %f\n", NPVARIANT_TO_DOUBLE(variant));
+    	PLUGIN_DEBUG("DOUBLE: %f\n", NPVARIANT_TO_DOUBLE(variant));
     }
     else if (NPVARIANT_IS_STRING(variant))
     {
 #if MOZILLA_VERSION_COLLAPSED < 1090200
-    	PLUGIN_DEBUG_1ARG("STRING: %s\n", NPVARIANT_TO_STRING(variant).utf8characters);
+    	PLUGIN_DEBUG("STRING: %s\n", NPVARIANT_TO_STRING(variant).utf8characters);
 #else
-    	PLUGIN_DEBUG_1ARG("STRING: %s\n", NPVARIANT_TO_STRING(variant).UTF8Characters);
+    	PLUGIN_DEBUG("STRING: %s\n", NPVARIANT_TO_STRING(variant).UTF8Characters);
 #endif
     }
     else
     {
-    	PLUGIN_DEBUG_1ARG("OBJ: %p\n", NPVARIANT_TO_OBJECT(variant));
+    	PLUGIN_DEBUG("OBJ: %p\n", NPVARIANT_TO_OBJECT(variant));
     }
 }
 
@@ -738,19 +738,19 @@
 
         if (value == "void")
         {
-            PLUGIN_DEBUG_0ARG("Method call returned void\n");
+            PLUGIN_DEBUG("Method call returned void\n");
             VOID_TO_NPVARIANT(*variant);
         } else if (value == "null")
         {
-            PLUGIN_DEBUG_0ARG("Method call returned null\n");
+            PLUGIN_DEBUG("Method call returned null\n");
             NULL_TO_NPVARIANT(*variant);
         }else if (value == "true")
         {
-            PLUGIN_DEBUG_0ARG("Method call returned a boolean (true)\n");
+            PLUGIN_DEBUG("Method call returned a boolean (true)\n");
             BOOLEAN_TO_NPVARIANT(true, *variant);
         } else if (value == "false")
         {
-            PLUGIN_DEBUG_0ARG("Method call returned a boolean (false)\n");
+            PLUGIN_DEBUG("Method call returned a boolean (false)\n");
             BOOLEAN_TO_NPVARIANT(false, *variant);
         } else
         {
@@ -761,12 +761,12 @@
                 d < -(0x7fffffffL - 1L) ||
                 d > 0x7fffffffL)
             {
-                PLUGIN_DEBUG_1ARG("Method call returned a double %f\n", d);
+                PLUGIN_DEBUG("Method call returned a double %f\n", d);
                 DOUBLE_TO_NPVARIANT(d, *variant);
             } else
             {
                 int32_t i = (int32_t) d;
-                PLUGIN_DEBUG_1ARG("Method call returned an int %d\n", i);
+                PLUGIN_DEBUG("Method call returned an int %d\n", i);
                 INT32_TO_NPVARIANT(i, *variant);
             }
         }
@@ -803,7 +803,7 @@
             NPUTF8* return_str = (NPUTF8*) malloc(sizeof(NPUTF8)*java_result->return_string->size() + 1);
             strcpy(return_str, java_result->return_string->c_str());
 
-            PLUGIN_DEBUG_1ARG("Method call returned a string: \"%s\"\n", return_str);
+            PLUGIN_DEBUG("Method call returned a string: \"%s\"\n", return_str);
             STRINGZ_TO_NPVARIANT(return_str, *variant);
 
         } else {
@@ -865,7 +865,7 @@
     constructor_name.append(NPVARIANT_TO_STRING(constructor_str).UTF8Characters);
 #endif
 
-    PLUGIN_DEBUG_1ARG("Constructor for NPObject is %s\n", constructor_name.c_str());
+    PLUGIN_DEBUG("Constructor for NPObject is %s\n", constructor_name.c_str());
 
     return constructor_name.find("function Array") == 0;
 }
@@ -874,7 +874,7 @@
 IcedTeaPluginUtilities::decodeURL(const gchar* url, gchar** decoded_url)
 {
 
-    PLUGIN_DEBUG_2ARG("GOT URL: %s -- %s\n", url, *decoded_url);
+    PLUGIN_DEBUG("GOT URL: %s -- %s\n", url, *decoded_url);
     int length = strlen(url);
     for (int i=0; i < length; i++)
     {
@@ -903,7 +903,7 @@
         }
     }
 
-    PLUGIN_DEBUG_1ARG("SENDING URL: %s\n", *decoded_url);
+    PLUGIN_DEBUG("SENDING URL: %s\n", *decoded_url);
 }
 
 /******************************************
@@ -951,13 +951,13 @@
 	ret = pthread_mutex_init(&subscriber_mutex, NULL);
 
 	if(ret)
-		PLUGIN_DEBUG_1ARG("Error: Unable to initialize subscriber mutex: %d\n", ret);
+		PLUGIN_DEBUG("Error: Unable to initialize subscriber mutex: %d\n", ret);
 
 	ret = pthread_mutex_init(&msg_queue_mutex, NULL);
 	if(ret)
-		PLUGIN_DEBUG_1ARG("Error: Unable to initialize message queue mutex: %d\n", ret);
+		PLUGIN_DEBUG("Error: Unable to initialize message queue mutex: %d\n", ret);
 
-	PLUGIN_DEBUG_2ARG("Mutexs %p and %p initialized\n", &subscriber_mutex, &msg_queue_mutex);
+	PLUGIN_DEBUG("Mutexs %p and %p initialized\n", &subscriber_mutex, &msg_queue_mutex);
 }
 
 /**
@@ -968,17 +968,17 @@
 
 MessageBus::~MessageBus()
 {
-    PLUGIN_DEBUG_0ARG("MessageBus::~MessageBus\n");
+    PLUGIN_DEBUG("MessageBus::~MessageBus\n");
 
 	int ret;
 
 	ret = pthread_mutex_destroy(&subscriber_mutex);
 	if(ret)
-		PLUGIN_DEBUG_1ARG("Error: Unable to destroy subscriber mutex: %d\n", ret);
+		PLUGIN_DEBUG("Error: Unable to destroy subscriber mutex: %d\n", ret);
 
 	ret = pthread_mutex_destroy(&msg_queue_mutex);
 	if(ret)
-			PLUGIN_DEBUG_1ARG("Error: Unable to destroy message queue mutex: %d\n", ret);
+			PLUGIN_DEBUG("Error: Unable to destroy message queue mutex: %d\n", ret);
 }
 
 /**
@@ -991,7 +991,7 @@
 {
     // Applets may initialize in parallel. So lock before pushing.
 
-	PLUGIN_DEBUG_2ARG("Subscribing %p to bus %p\n", b, this);
+	PLUGIN_DEBUG("Subscribing %p to bus %p\n", b, this);
     pthread_mutex_lock(&subscriber_mutex);
     subscribers.push_back(b);
     pthread_mutex_unlock(&subscriber_mutex);
@@ -1007,7 +1007,7 @@
 {
     // Applets may initialize in parallel. So lock before pushing.
 
-	PLUGIN_DEBUG_2ARG("Un-subscribing %p from bus %p\n", b, this);
+	PLUGIN_DEBUG("Un-subscribing %p from bus %p\n", b, this);
     pthread_mutex_lock(&subscriber_mutex);
     subscribers.remove(b);
     pthread_mutex_unlock(&subscriber_mutex);
@@ -1027,21 +1027,21 @@
 	// consumer frees this memory
 	strcpy(msg, message);
 
-	PLUGIN_DEBUG_1ARG("Trying to lock %p...\n", &msg_queue_mutex);
+	PLUGIN_DEBUG("Trying to lock %p...\n", &msg_queue_mutex);
 	pthread_mutex_lock(&subscriber_mutex);
 
-    PLUGIN_DEBUG_1ARG("Message %s received on bus. Notifying subscribers.\n", msg);
+    PLUGIN_DEBUG("Message %s received on bus. Notifying subscribers.\n", msg);
 
     std::list<BusSubscriber*>::const_iterator i;
     for( i = subscribers.begin(); i != subscribers.end() && !message_consumed; ++i ) {
-    	PLUGIN_DEBUG_2ARG("Notifying subscriber %p of %s\n", *i, msg);
+    	PLUGIN_DEBUG("Notifying subscriber %p of %s\n", *i, msg);
     	message_consumed = ((BusSubscriber*) *i)->newMessageOnBus(msg);
     }
 
     pthread_mutex_unlock(&subscriber_mutex);
 
     if (!message_consumed)
-    	PLUGIN_DEBUG_1ARG("Warning: No consumer found for message %s\n", msg);
+    	PLUGIN_DEBUG("Warning: No consumer found for message %s\n", msg);
 
-    PLUGIN_DEBUG_1ARG("%p unlocked...\n", &msg_queue_mutex);
+    PLUGIN_DEBUG("%p unlocked...\n", &msg_queue_mutex);
 }
diff -r d1ad52447673 plugin/icedteanp/IcedTeaPluginUtils.h
--- a/plugin/icedteanp/IcedTeaPluginUtils.h	Wed Apr 14 12:21:30 2010 +0200
+++ b/plugin/icedteanp/IcedTeaPluginUtils.h	Tue Jul 20 16:36:52 2010 +0200
@@ -66,64 +66,14 @@
 
 #include "IcedTeaNPPlugin.h"
 
-#define PLUGIN_DEBUG_0ARG(str) \
-  do                                        \
-  {                                         \
-    if (plugin_debug)                       \
-    {                                       \
-      fprintf(stderr, "ICEDTEA NP PLUGIN: thread %p: ", pthread_self()); \
-      fprintf(stderr, str);                \
-    }                                       \
-  } while (0)
-
-#define PLUGIN_DEBUG_1ARG(str, arg1) \
-  do                                        \
-  {                                         \
-    if (plugin_debug)                       \
-    {                                       \
-      fprintf(stderr, "ICEDTEA NP PLUGIN: thread %p: ", pthread_self()); \
-      fprintf(stderr, str, arg1);          \
-    }                                       \
-  } while (0)
-
-#define PLUGIN_DEBUG_2ARG(str, arg1, arg2)  \
-  do                                        \
-  {                                         \
-    if (plugin_debug)                       \
-    {                                       \
-      fprintf(stderr, "ICEDTEA NP PLUGIN: thread %p: ", pthread_self()); \
-      fprintf(stderr, str, arg1, arg2);    \
-    }                                       \
-  } while (0)
-
-#define PLUGIN_DEBUG_3ARG(str, arg1, arg2, arg3) \
-  do                                           \
-  {                                            \
-    if (plugin_debug)                          \
-    {                                          \
-      fprintf(stderr, "ICEDTEA NP PLUGIN: thread %p: ", pthread_self()); \
-      fprintf(stderr, str, arg1, arg2, arg3); \
-    }                                          \
-  } while (0)
-
-#define PLUGIN_DEBUG_4ARG(str, arg1, arg2, arg3, arg4) \
-  do                                                 \
-  {                                                  \
-    if (plugin_debug)                                \
-    {                                                \
-      fprintf(stderr, "ICEDTEA NP PLUGIN: thread %p: ", pthread_self()); \
-      fprintf(stderr, str, arg1, arg2, arg3, arg4); \
-    }                                                \
-  } while (0)
-
-#define PLUGIN_DEBUG_5ARG(str, arg1, arg2, arg3, arg4, arg5) \
-  do                                                 \
-  {                                                  \
-    if (plugin_debug)                                \
-    {                                                \
-      fprintf(stderr, "ICEDTEA NP PLUGIN: thread %p: ", pthread_self()); \
-      fprintf(stderr, str, arg1, arg2, arg3, arg4, arg5); \
-    }                                                \
+#define PLUGIN_DEBUG(...) \
+  do                                                          \
+  {                                                           \
+    if (plugin_debug)                                         \
+    {                                                         \
+      fprintf (stderr, "ITNPP Thread# %ld: ", pthread_self()); \
+      fprintf (stderr, __VA_ARGS__);                          \
+    }                                                         \
   } while (0)
 
 #define CHECK_JAVA_RESULT(result_data)                               \
@@ -137,8 +87,8 @@
 }
 
 #define HEX_TO_INT(c) \
-    ((*c >= 'A') ? *c - 'A' + 10 : \
-     (*c >= 'a') ? *c - 'a' + 10 : \
+    ((*c >= 'a') ? *c - 'a' + 10 : \
+     (*c >= 'A') ? *c - 'A' + 10 : \
      *c - '0')
 
 #define IS_VALID_HEX(c) \
diff -r d1ad52447673 plugin/icedteanp/IcedTeaScriptablePluginObject.cc
--- a/plugin/icedteanp/IcedTeaScriptablePluginObject.cc	Wed Apr 14 12:21:30 2010 +0200
+++ b/plugin/icedteanp/IcedTeaScriptablePluginObject.cc	Tue Jul 20 16:36:52 2010 +0200
@@ -135,7 +135,7 @@
 NPObject*
 allocate_scriptable_jp_object(NPP npp, NPClass *aClass)
 {
-    PLUGIN_DEBUG_0ARG("Allocating new scriptable Java Package object\n");
+    PLUGIN_DEBUG("Allocating new scriptable Java Package object\n");
     return new IcedTeaScriptableJavaPackageObject(npp);
 }
 
@@ -161,7 +161,7 @@
 	np_class->construct = IcedTeaScriptableJavaPackageObject::construct;
 
 	scriptable_object = browser_functions.createobject(instance, np_class);
-	PLUGIN_DEBUG_3ARG("Returning new scriptable package class: %p from instance %p with name %s\n", scriptable_object, instance, name);
+	PLUGIN_DEBUG("Returning new scriptable package class: %p from instance %p with name %s\n", scriptable_object, instance, name);
 
     ((IcedTeaScriptableJavaPackageObject*) scriptable_object)->setPackageName(name);
 
@@ -172,7 +172,7 @@
 
 IcedTeaScriptableJavaPackageObject::IcedTeaScriptableJavaPackageObject(NPP instance)
 {
-    PLUGIN_DEBUG_0ARG("Constructing new scriptable java package object\n");
+    PLUGIN_DEBUG("Constructing new scriptable java package object\n");
 	this->instance = instance;
 	this->package_name = new std::string();
 }
@@ -232,7 +232,7 @@
 bool
 IcedTeaScriptableJavaPackageObject::hasProperty(NPObject *npobj, NPIdentifier name)
 {
-	PLUGIN_DEBUG_1ARG("IcedTeaScriptableJavaPackageObject::hasProperty %s\n", browser_functions.utf8fromidentifier(name));
+	PLUGIN_DEBUG("IcedTeaScriptableJavaPackageObject::hasProperty %s\n", browser_functions.utf8fromidentifier(name));
 
 	bool hasProperty = false;
 	JavaResultData* java_result;
@@ -240,7 +240,7 @@
     NPP instance = IcedTeaPluginUtilities::getInstanceFromMemberPtr(npobj);
     int plugin_instance_id = get_id_from_instance(instance);
 
-	PLUGIN_DEBUG_1ARG("Object package name: \"%s\"\n", ((IcedTeaScriptableJavaPackageObject*) npobj)->getPackageName().c_str());
+	PLUGIN_DEBUG("Object package name: \"%s\"\n", ((IcedTeaScriptableJavaPackageObject*) npobj)->getPackageName().c_str());
 
 	// "^java" is always a package
 	if (((IcedTeaScriptableJavaPackageObject*) npobj)->getPackageName().length() == 0 &&
@@ -255,7 +255,7 @@
 	    property_name += ".";
 	property_name += browser_functions.utf8fromidentifier(name);
 
-	PLUGIN_DEBUG_1ARG("Looking for name \"%s\"\n", property_name.c_str());
+	PLUGIN_DEBUG("Looking for name \"%s\"\n", property_name.c_str());
 
 	java_result = java_request->hasPackage(plugin_instance_id, property_name);
 
@@ -278,7 +278,7 @@
 IcedTeaScriptableJavaPackageObject::getProperty(NPObject *npobj, NPIdentifier name, NPVariant *result)
 {
 
-	PLUGIN_DEBUG_1ARG("IcedTeaScriptableJavaPackageObject::getProperty %s\n", browser_functions.utf8fromidentifier(name));
+	PLUGIN_DEBUG("IcedTeaScriptableJavaPackageObject::getProperty %s\n", browser_functions.utf8fromidentifier(name));
 
 	if (!browser_functions.utf8fromidentifier(name))
 	    return false;
@@ -303,14 +303,14 @@
 
 	if (isPropertyClass)
 	{
-		PLUGIN_DEBUG_0ARG("Returning package object\n");
+		PLUGIN_DEBUG("Returning package object\n");
 		obj = IcedTeaScriptablePluginObject::get_scriptable_java_package_object(
                                   IcedTeaPluginUtilities::getInstanceFromMemberPtr(npobj),
                                   property_name.c_str());
 	}
 	else
 	{
-		PLUGIN_DEBUG_0ARG("Returning Java object\n");
+		PLUGIN_DEBUG("Returning Java object\n");
 		obj = IcedTeaScriptableJavaPackageObject::get_scriptable_java_object(
 		                IcedTeaPluginUtilities::getInstanceFromMemberPtr(npobj),
 		                *(java_result->return_string), "0", false);
@@ -353,7 +353,7 @@
 NPObject*
 allocate_scriptable_java_object(NPP npp, NPClass *aClass)
 {
-    PLUGIN_DEBUG_0ARG("Allocating new scriptable Java object\n");
+    PLUGIN_DEBUG("Allocating new scriptable Java object\n");
     return new IcedTeaScriptableJavaObject(npp);
 }
 
@@ -370,12 +370,12 @@
     obj_key += ":";
     obj_key += instance_id;
 
-    PLUGIN_DEBUG_1ARG("get_scriptable_java_object searching for %s...\n", obj_key.c_str());
+    PLUGIN_DEBUG("get_scriptable_java_object searching for %s...\n", obj_key.c_str());
     scriptable_object = IcedTeaPluginUtilities::getNPObjectFromJavaKey(obj_key);
 
     if (scriptable_object != NULL)
     {
-        PLUGIN_DEBUG_1ARG("Returning existing object %p\n", scriptable_object);
+        PLUGIN_DEBUG("Returning existing object %p\n", scriptable_object);
         browser_functions.retainobject(scriptable_object);
         return scriptable_object;
     }
@@ -420,7 +420,7 @@
         browser_functions.retainobject(scriptable_object);
     }
 
-    PLUGIN_DEBUG_4ARG("Constructed new Java Object with classid=%s, instanceid=%s, isArray=%d and scriptable_object=%p\n", class_id.c_str(), instance_id.c_str(), isArray, scriptable_object);
+    PLUGIN_DEBUG("Constructed new Java Object with classid=%s, instanceid=%s, isArray=%d and scriptable_object=%p\n", class_id.c_str(), instance_id.c_str(), isArray, scriptable_object);
 
 	((IcedTeaScriptableJavaObject*) scriptable_object)->setClassIdentifier(class_id);
     ((IcedTeaScriptableJavaObject*) scriptable_object)->setIsArray(isArray);
@@ -431,7 +431,7 @@
 	IcedTeaPluginUtilities::storeInstanceID(scriptable_object, instance);
 	IcedTeaPluginUtilities::storeObjectMapping(obj_key, scriptable_object);
 
-	PLUGIN_DEBUG_2ARG("Inserting into object_map key %s->%p\n", obj_key.c_str(), scriptable_object);
+	PLUGIN_DEBUG("Inserting into object_map key %s->%p\n", obj_key.c_str(), scriptable_object);
 	return scriptable_object;
 }
 
@@ -439,7 +439,7 @@
 void
 _createAndRetainJavaObject(void* data)
 {
-    PLUGIN_DEBUG_0ARG("Asynchronously creating/retaining object ...\n");
+    PLUGIN_DEBUG("Asynchronously creating/retaining object ...\n");
 
     std::vector<void*> parameters = ((AsyncCallThreadData*) data)->parameters;
     NPP instance = (NPP) parameters.at(0);
@@ -510,7 +510,7 @@
 bool
 IcedTeaScriptableJavaObject::hasMethod(NPObject *npobj, NPIdentifier name)
 {
-    PLUGIN_DEBUG_2ARG("IcedTeaScriptableJavaObject::hasMethod %s (ival=%d)\n", browser_functions.utf8fromidentifier(name), browser_functions.intfromidentifier(name));
+    PLUGIN_DEBUG("IcedTeaScriptableJavaObject::hasMethod %s (ival=%d)\n", browser_functions.utf8fromidentifier(name), browser_functions.intfromidentifier(name));
     bool hasMethod = false;
 
     // If object is an array and requested "method" may be a number, check for it first
@@ -531,7 +531,7 @@
         hasMethod = java_result->return_identifier != 0;
     }
 
-    PLUGIN_DEBUG_1ARG("IcedTeaScriptableJavaObject::hasMethod returning %d\n", hasMethod);
+    PLUGIN_DEBUG("IcedTeaScriptableJavaObject::hasMethod returning %d\n", hasMethod);
     return hasMethod;
 }
 
@@ -542,7 +542,7 @@
     NPUTF8* method_name = browser_functions.utf8fromidentifier(name);
 
     // Extract arg type array
-    PLUGIN_DEBUG_1ARG("IcedTeaScriptableJavaObject::invoke %s. Args follow.\n", method_name);
+    PLUGIN_DEBUG("IcedTeaScriptableJavaObject::invoke %s. Args follow.\n", method_name);
     for (int i=0; i < argCount; i++)
     {
         IcedTeaPluginUtilities::printNPVariant(args[i]);
@@ -577,14 +577,14 @@
 
     if (instance_id.length() == 0) // Static
     {
-        PLUGIN_DEBUG_0ARG("Calling static method\n");
+        PLUGIN_DEBUG("Calling static method\n");
         callee = ((IcedTeaScriptableJavaObject*) npobj)->getClassID();
         java_result = java_request.callStaticMethod(
                         IcedTeaPluginUtilities::getSourceFromInstance(instance),
                         callee, browser_functions.utf8fromidentifier(name), arg_ids);
     } else
     {
-        PLUGIN_DEBUG_0ARG("Calling method normally\n");
+        PLUGIN_DEBUG("Calling method normally\n");
         callee = ((IcedTeaScriptableJavaObject*) npobj)->getInstanceID();
         java_result = java_request.callMethod(
                         IcedTeaPluginUtilities::getSourceFromInstance(instance),
@@ -600,7 +600,7 @@
         return false;
     }
 
-    PLUGIN_DEBUG_0ARG("IcedTeaScriptableJavaObject::invoke converting and returning.\n");
+    PLUGIN_DEBUG("IcedTeaScriptableJavaObject::invoke converting and returning.\n");
     return IcedTeaPluginUtilities::javaResultToNPVariant(instance, java_result->return_string, result);
 }
 
@@ -615,7 +615,7 @@
 bool
 IcedTeaScriptableJavaObject::hasProperty(NPObject *npobj, NPIdentifier name)
 {
-    PLUGIN_DEBUG_2ARG("IcedTeaScriptableJavaObject::hasProperty %s (ival=%d)\n", browser_functions.utf8fromidentifier(name), browser_functions.intfromidentifier(name));
+    PLUGIN_DEBUG("IcedTeaScriptableJavaObject::hasProperty %s (ival=%d)\n", browser_functions.utf8fromidentifier(name), browser_functions.intfromidentifier(name));
     bool hasProperty = false;
 
     // If it is an array, only length and indexes are valid
@@ -648,14 +648,14 @@
         }
     }
 
-	PLUGIN_DEBUG_1ARG("IcedTeaScriptableJavaObject::hasProperty returning %d\n", hasProperty);
+	PLUGIN_DEBUG("IcedTeaScriptableJavaObject::hasProperty returning %d\n", hasProperty);
 	return hasProperty;
 }
 
 bool
 IcedTeaScriptableJavaObject::getProperty(NPObject *npobj, NPIdentifier name, NPVariant *result)
 {
-    PLUGIN_DEBUG_2ARG("IcedTeaScriptableJavaObject::getProperty %s (ival=%d)\n", browser_functions.utf8fromidentifier(name), browser_functions.intfromidentifier(name));
+    PLUGIN_DEBUG("IcedTeaScriptableJavaObject::getProperty %s (ival=%d)\n", browser_functions.utf8fromidentifier(name), browser_functions.intfromidentifier(name));
 
     bool isPropertyClass = false;
     JavaResultData* java_result;
@@ -730,14 +730,14 @@
         return false;
     }
 
-    PLUGIN_DEBUG_0ARG("IcedTeaScriptableJavaObject::getProperty converting and returning.\n");
+    PLUGIN_DEBUG("IcedTeaScriptableJavaObject::getProperty converting and returning.\n");
     return IcedTeaPluginUtilities::javaResultToNPVariant(instance, java_result->return_string, result);
 }
 
 bool
 IcedTeaScriptableJavaObject::setProperty(NPObject *npobj, NPIdentifier name, const NPVariant *value)
 {
-    PLUGIN_DEBUG_2ARG("IcedTeaScriptableJavaObject::setProperty %s (ival=%d) to:\n", browser_functions.utf8fromidentifier(name), browser_functions.intfromidentifier(name));
+    PLUGIN_DEBUG("IcedTeaScriptableJavaObject::setProperty %s (ival=%d) to:\n", browser_functions.utf8fromidentifier(name), browser_functions.intfromidentifier(name));
     IcedTeaPluginUtilities::printNPVariant(*value);
 
     bool isPropertyClass = false;
@@ -811,7 +811,7 @@
         return false;
     }
 
-    PLUGIN_DEBUG_0ARG("IcedTeaScriptableJavaObject::setProperty returning.\n");
+    PLUGIN_DEBUG("IcedTeaScriptableJavaObject::setProperty returning.\n");
     return true;
 }
 
@@ -834,7 +834,7 @@
 	           NPVariant *result)
 {
     // Extract arg type array
-    PLUGIN_DEBUG_1ARG("IcedTeaScriptableJavaObject::construct %s. Args follow.\n", ((IcedTeaScriptableJavaObject*) npobj)->getClassID().c_str());
+    PLUGIN_DEBUG("IcedTeaScriptableJavaObject::construct %s. Args follow.\n", ((IcedTeaScriptableJavaObject*) npobj)->getClassID().c_str());
     for (int i=0; i < argCount; i++)
     {
         IcedTeaPluginUtilities::printNPVariant(args[i]);
@@ -892,6 +892,6 @@
 
     OBJECT_TO_NPVARIANT(obj, *result);
 
-    PLUGIN_DEBUG_0ARG("IcedTeaScriptableJavaObject::construct returning.\n");
+    PLUGIN_DEBUG("IcedTeaScriptableJavaObject::construct returning.\n");
     return true;
 }
diff -r d1ad52447673 plugin/icedteanp/java/netscape/security/ForbiddenTargetException.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/plugin/icedteanp/java/netscape/security/ForbiddenTargetException.java	Tue Jul 20 16:36:52 2010 +0200
@@ -0,0 +1,52 @@
+/* ForbiddenTargetException.java
+   Copyright (C) 2010  Red Hat
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package netscape.security;
+
+public class ForbiddenTargetException extends RuntimeException{
+
+    private static final long serialVersionUID = 1271219852541058396L;
+
+    public ForbiddenTargetException() {
+        super();
+    }
+
+    public ForbiddenTargetException(String s) {
+        super(s);
+    }
+
+}
diff -r d1ad52447673 plugin/icedteanp/java/sun/applet/PluginAppletViewer.java
--- a/plugin/icedteanp/java/sun/applet/PluginAppletViewer.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/plugin/icedteanp/java/sun/applet/PluginAppletViewer.java	Tue Jul 20 16:36:52 2010 +0200
@@ -1,4 +1,4 @@
-/* VoidPluginCallRequest -- represent Java-to-JavaScript requests
+/* PluginAppletViewer -- Handles embedding of the applet panel
    Copyright (C) 2008  Red Hat 
 
 This file is part of IcedTea.
@@ -393,8 +393,7 @@
          if (oldFrame != null && handle == oldFrame.handle)
              return;
 
-         PluginAppletViewer newFrame = new PluginAppletViewer(handle, identifier, statusMsgStream, heightFactor, widthFactor);
-         newFrame.panel = panel;
+         PluginAppletViewer newFrame = new PluginAppletViewer(handle, identifier, statusMsgStream, heightFactor, widthFactor, panel);
 
          if (oldFrame != null) {
              applets.remove(oldFrame.identifier);
@@ -425,13 +424,14 @@
       */
      private PluginAppletViewer(long handle, final int identifier, 
                          PrintStream statusMsgStream, double heightFactor, 
-                         double widthFactor) {
+                         double widthFactor, AppletViewerPanel appletPanel) {
          
          super(handle, true);
          this.statusMsgStream = statusMsgStream;
          this.identifier = identifier;
          this.proposedHeightFactor = heightFactor;
          this.proposedWidthFactor = widthFactor;
+         this.panel = appletPanel;
 
          if (!appletPanels.contains(panel))
              appletPanels.addElement(panel);
@@ -735,7 +735,7 @@
                       Thread.sleep(50);
                       wait += 50;
                   } catch (InterruptedException ie) {
-                      ie.printStackTrace();
+                      // just wait
                   }
              }
              
@@ -1605,10 +1605,15 @@
          {
              public void run()
              {
+                 ThreadGroup tg = ((JNLPClassLoader) p.applet.getClass().getClassLoader()).getApplication().getThreadGroup();
+                
                  appletShutdown(p);
                  appletPanels.removeElement(p);
                  dispose();
 
+                 if (tg.activeCount() > 0)
+                 tg.stop();
+
                  if (countApplets() == 0) {
                      appletSystemExit();
                  }
diff -r d1ad52447673 plugin/icedteanp/java/sun/applet/PluginMessageConsumer.java
--- a/plugin/icedteanp/java/sun/applet/PluginMessageConsumer.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/plugin/icedteanp/java/sun/applet/PluginMessageConsumer.java	Tue Jul 20 16:36:52 2010 +0200
@@ -61,6 +61,7 @@
 	PluginStreamHandler streamHandler = null;
 	AppletSecurity as;
 	ConsumerThread consumerThread = new ConsumerThread();
+	private static ArrayList<Integer> processedIds = new ArrayList<Integer>();
 
 	/** 
 	 * Registers a reference to wait for. Responses to registered priority 
@@ -162,15 +163,24 @@
 	        }
 	        
 	        registerPriorityWait("instance " + instanceNum + " handle");
-	        registerPriorityWait("instance " + instanceNum + " width");
 
-	    } else if (msgParts[2].equals("handle") || msgParts[2].equals("width")) {
+	    } else if (msgParts[2].equals("handle")) {
 	            Integer instanceNum = new Integer(msgParts[1]);
 
 	            // If this instance is not in init, return false immediately. 
-	            // Handle/Width messages should NEVER go before tag messages
+	            // Handle messages should NEVER go before tag messages
 	            if (!isInInit(instanceNum))
 	                return false;
+
+		        registerPriorityWait("instance " + instanceNum + " width");
+	    } else if (msgParts[2].equals("width")) {
+	    	
+	    	// width messages cannot proceed until handle and tag have been resolved
+	    	Integer instanceNum = new Integer(msgParts[1]);
+
+	    	if (!processedIds.contains(instanceNum)) {
+                return false;
+            }
 	    }
 
 	    return true;
@@ -181,8 +191,10 @@
 	        Iterator<Integer> i = initWorkers.keySet().iterator();
             while (i.hasNext()) {
                 Integer key = i.next();
-                if (initWorkers.get(key).equals(worker))
+                if (initWorkers.get(key).equals(worker)) {
+                    processedIds.add(key);
                     initWorkers.remove(key);
+                }
             }
 	    }
 	    
@@ -270,7 +282,7 @@
 			if (workers.size() <= MAX_WORKERS) {
 			    PluginMessageHandlerWorker worker = null;
 			    
-			    if (workers.size() <= (MAX_WORKERS - PRIORITY_WORKERS)) {
+			    if (workers.size() < (MAX_WORKERS - PRIORITY_WORKERS)) {
 			        PluginDebug.debug("Cannot find free worker, creating worker " + workers.size());
 			        worker = new PluginMessageHandlerWorker(this, streamHandler, workers.size(), as, false);
 			    } else if (prioritized) {
@@ -291,4 +303,9 @@
 			return null;
 	}
 	
+	private void dumpWorkerStatus() {
+		for (PluginMessageHandlerWorker worker: workers) {
+			PluginDebug.debug(worker.toString());
+		}
+	}
 }
diff -r d1ad52447673 plugin/icedteanp/java/sun/applet/PluginMessageHandlerWorker.java
--- a/plugin/icedteanp/java/sun/applet/PluginMessageHandlerWorker.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/plugin/icedteanp/java/sun/applet/PluginMessageHandlerWorker.java	Tue Jul 20 16:36:52 2010 +0200
@@ -72,7 +72,7 @@
 
 			if (message != null) {
 				
-			    PluginDebug.debug("Consumer thread " + id + " consuming " + message);
+			    PluginDebug.debug("Consumer (priority=" + isPriorityWorker + ") thread " + id + " consuming " + message);
 			    
 				// ideally, whoever returns things object should mark it 
 				// busy first, but just in case..
@@ -90,7 +90,7 @@
 
 				this.message = null;
 				
-				PluginDebug.debug("Consumption completed by consumer thread " + id);
+				PluginDebug.debug("Consumption (priority=" + isPriorityWorker + ") completed by consumer thread " + id);
 
 	            // mark ourselves free again
 				free();
@@ -140,4 +140,8 @@
 	        return free && (prioritized == isPriorityWorker);
 	    }
 	}
+
+	public String toString() {
+		return "Worker #" + this.id + "/IsPriority=" + this.isPriorityWorker + "/IsFree=" + this.free + "/Message=" + message;  
+	}
 }
diff -r d1ad52447673 ports/hotspot/src/share/vm/shark/sharkNativeWrapper.cpp
--- a/ports/hotspot/src/share/vm/shark/sharkNativeWrapper.cpp	Wed Apr 14 12:21:30 2010 +0200
+++ b/ports/hotspot/src/share/vm/shark/sharkNativeWrapper.cpp	Tue Jul 20 16:36:52 2010 +0200
@@ -98,7 +98,8 @@
   if (is_static()) {
     builder()->CreateStore(
       builder()->CreateInlineOop(
-        JNIHandles::make_local(target()->method_holder())),
+        JNIHandles::make_local(
+        target()->method_holder()->klass_part()->java_mirror())),
       oop_tmp_slot());
 
     param_types.push_back(box_type);
@@ -326,11 +327,11 @@
       needs_cast = true;
       break;
 
-    case T_BYTE:
+    case T_CHAR:
       needs_cast = true;
       break;
 
-    case T_CHAR:
+    case T_BYTE:
     case T_SHORT:
       needs_cast = true;
       is_signed = true;
diff -r d1ad52447673 ports/hotspot/src/share/vm/shark/sharkTopLevelBlock.cpp
--- a/ports/hotspot/src/share/vm/shark/sharkTopLevelBlock.cpp	Wed Apr 14 12:21:30 2010 +0200
+++ b/ports/hotspot/src/share/vm/shark/sharkTopLevelBlock.cpp	Tue Jul 20 16:36:52 2010 +0200
@@ -691,12 +691,6 @@
   SharkValue *index = pop();
   SharkValue *array = pop();
 
-  assert(array->type()->is_array_klass(), "should be");
-  ciType *element_type = ((ciArrayKlass *) array->type())->element_type();
-  assert((element_type->basic_type() == T_BOOLEAN && basic_type == T_BYTE) ||
-         (element_type->basic_type() == T_ARRAY && basic_type == T_OBJECT) ||
-         (element_type->basic_type() == basic_type), "type mismatch");
-
   check_null(array);
   check_bounds(array, index);
 
@@ -729,7 +723,21 @@
     break;
 
   case T_OBJECT:
-    push(SharkValue::create_generic(element_type, value, false));
+    // You might expect that array->type()->is_array_klass() would
+    // always be true, but it isn't.  If ciTypeFlow detects that a
+    // value is always null then that value becomes an untyped null
+    // object.  Shark doesn't presently support this, so a generic
+    // T_OBJECT is created.  In this case we guess the type using
+    // the BasicType we were supplied.  In reality the generated
+    // code will never be used, as the null value will be caught
+    // by the above null pointer check.
+    // http://icedtea.classpath.org/bugzilla/show_bug.cgi?id=324
+    push(
+      SharkValue::create_generic(
+        array->type()->is_array_klass() ?
+          ((ciArrayKlass *) array->type())->element_type() :
+          ciType::make(basic_type),
+        value, false));
     break;
 
   default:
@@ -743,12 +751,6 @@
   SharkValue *index  = pop();
   SharkValue *array  = pop();
 
-  assert(array->type()->is_array_klass(), "should be");
-  ciType *element_type = ((ciArrayKlass *) array->type())->element_type();
-  assert((element_type->basic_type() == T_BOOLEAN && basic_type == T_BYTE) ||
-         (element_type->basic_type() == T_ARRAY && basic_type == T_OBJECT) ||
-         (element_type->basic_type() == basic_type), "type mismatch");
-
   check_null(array);
   check_bounds(array, index);
 
@@ -792,7 +794,7 @@
 
   builder()->CreateStore(value, addr);
 
-  if (!element_type->is_primitive_type())
+  if (basic_type == T_OBJECT) // XXX or T_ARRAY?
     builder()->CreateUpdateBarrierSet(oopDesc::bs(), addr);
 }
 
@@ -901,6 +903,18 @@
       dest_method->holder() == java_lang_Object_klass())
     return dest_method;
 
+#ifdef SHARK_CAN_DEOPTIMIZE_ANYWHERE
+  // This code can replace a virtual call with a direct call if this
+  // class is the only one in the entire set of loaded classes that
+  // implements this method.  This makes the compiled code dependent
+  // on other classes that implement the method not being loaded, a
+  // condition which is enforced by the dependency tracker.  If the
+  // dependency tracker determines a method has become invalid it
+  // will mark it for recompilation, causing running copies to be
+  // deoptimized.  Shark currently can't deoptimize arbitrarily like
+  // that, so this optimization cannot be used.
+  // http://icedtea.classpath.org/bugzilla/show_bug.cgi?id=481
+  
   // All other interesting cases are instance classes
   if (!receiver_type->is_instance_klass())
     return NULL;
@@ -956,6 +970,8 @@
   // with non-monomorphic targets if the receiver has an exact
   // type.  We don't mark types this way, so we can't do this.
 
+#endif // SHARK_CAN_DEOPTIMIZE_ANYWHERE
+
   return NULL;
 }
 
diff -r d1ad52447673 pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioDataLine.java
--- a/pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioDataLine.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioDataLine.java	Tue Jul 20 16:36:52 2010 +0200
@@ -86,7 +86,7 @@
 	protected void open(AudioFormat format, int bufferSize)
 			throws LineUnavailableException {
 
-		if (isOpen) {
+		if (isOpen()) {
 			throw new IllegalStateException("Line is already open");
 		}
 
@@ -139,7 +139,7 @@
 			}
 		}
 
-		if (!isOpen) {
+		if (!isOpen()) {
 			throw new IllegalArgumentException("Invalid format");
 		}
 
@@ -299,9 +299,10 @@
 	@Override
 	public void close() {
 
-		if (!isOpen) {
-			throw new IllegalStateException(
-					"Line must be open for close() to work");
+		if (!isOpen()) {
+			// For whatever reason, we are being asked to close
+			// a line that is not even open.
+			return;
 		}
 
 		synchronized (eventLoop.threadLock) {
@@ -346,7 +347,7 @@
 
 	@Override
 	public void start() {
-		if (!isOpen) {
+		if (!isOpen()) {
 			throw new IllegalStateException(
 					"Line must be open()ed before it can be start()ed");
 		}
@@ -376,10 +377,10 @@
 
 	@Override
 	public synchronized void stop() {
-		if (!isOpen) {
-			throw new IllegalStateException(
-					"Line must be open()ed before it can be start()ed");
-
+		if (!isOpen()) {
+			// For some reason, we are being asked to stop a line
+			// that isn't even open.
+			return;
 		}
 		writeInterrupted = true;
 		if (!isStarted) {
@@ -433,7 +434,7 @@
 			throws LineUnavailableException;
 
 	public Stream getStream() {
-		if (!isOpen) {
+		if (!isOpen()) {
 			throw new IllegalStateException("Line must be open");
 		}
 
@@ -442,7 +443,7 @@
 
 	@Override
 	public int getBufferSize() {
-		if (!isOpen) {
+		if (!isOpen()) {
 			return DEFAULT_BUFFER_SIZE;
 		}
 		return bufferSize;
@@ -450,7 +451,7 @@
 
 	@Override
 	public AudioFormat getFormat() {
-		if (!isOpen) {
+		if (!isOpen()) {
 			return defaultFormat;
 		}
 		return currentFormat;
@@ -467,7 +468,7 @@
 	 *            the name of this audio stream
 	 */
 	public void setName(String streamName) {
-		if (isOpen) {
+		if (isOpen()) {
 
 			Operation o;
 			synchronized (eventLoop.threadLock) {
diff -r d1ad52447673 pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioLine.java
--- a/pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioLine.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioLine.java	Tue Jul 20 16:36:52 2010 +0200
@@ -62,7 +62,7 @@
 
 	@Override
 	public void close() {
-		if (!isOpen) {
+		if (!isOpen()) {
 			throw new IllegalStateException("Line is not open");
 		}
 
@@ -79,7 +79,7 @@
 
 	@Override
 	public Control getControl(Type control) {
-		if (isOpen) {
+		if (isOpen()) {
 			for (Control aControl : controls) {
 				if (aControl.getType() == control) {
 					return aControl;
@@ -92,7 +92,7 @@
 
 	@Override
 	public Control[] getControls() {
-		if (!isOpen) {
+		if (!isOpen()) {
 			return new Control[] {};
 		}
 
diff -r d1ad52447673 pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioSourceDataLine.java
--- a/pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioSourceDataLine.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioSourceDataLine.java	Tue Jul 20 16:36:52 2010 +0200
@@ -142,8 +142,9 @@
 			writeInterrupted = false;
 		}
 
-		if (!isOpen) {
-			throw new IllegalStateException("must call open() before write()");
+		if (!isOpen()) {
+			// A closed line can write exactly 0 bytes.
+			return 0;
 		}
 
 		int frameSize = currentFormat.getFrameSize();
@@ -259,11 +260,6 @@
 
 	@Override
 	public void drain() {
-		if (!isOpen) {
-			throw new IllegalStateException(
-					"Line must be open before it can be drain()ed");
-
-		}
 
 		synchronized (this) {
 			writeInterrupted = true;
@@ -271,13 +267,13 @@
 
 		do {
 			synchronized (this) {
-				if (!isOpen) {
+				if (!isOpen()) {
 					return;
 				}
 				if (getBytesInBuffer() == 0) {
 					return;
 				}
-				if (isStarted || !isOpen) {
+				if (isStarted) {
 					break;
 				}
 				try {
@@ -301,29 +297,27 @@
 
 	@Override
 	public void flush() {
-		if (!isOpen) {
-			throw new IllegalStateException(
-					"Line must be open before it can be flush()ed");
-		}
 		synchronized (this) {
 			writeInterrupted = true;
 		}
 
-		Operation operation;
-		synchronized (eventLoop.threadLock) {
-			operation = stream.flush();
+		if (isOpen()) {
+			Operation operation;
+			synchronized (eventLoop.threadLock) {
+				operation = stream.flush();
+			}
+
+			operation.waitForCompletion();
+			operation.releaseReference();
 		}
 
-		operation.waitForCompletion();
-		operation.releaseReference();
-
 	}
 
 	@Override
 	synchronized public void close() {
 
-		if (!isOpen) {
-			throw new IllegalStateException("not open so cant close");
+		if (!isOpen()) {
+			return;
 		}
 
 		writeInterrupted = true;
diff -r d1ad52447673 pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioTargetDataLine.java
--- a/pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioTargetDataLine.java	Wed Apr 14 12:21:30 2010 +0200
+++ b/pulseaudio/src/java/org/classpath/icedtea/pulseaudio/PulseAudioTargetDataLine.java	Tue Jul 20 16:36:52 2010 +0200
@@ -76,15 +76,19 @@
 
 	@Override
 	synchronized public void close() {
+		if (!isOpen()) {
+			// Probably due to some programmer error, we are being
+			// asked to close an already closed line.  Oh well.
+			Debug.println(DebugLevel.Verbose,
+					"PulseAudioTargetDataLine.close(): "
+					+ "Line closed that wasn't open.");
+			return;
+		}
+
 		/* check for permission to record audio */
 		AudioPermission perm = new AudioPermission("record", null);
 		perm.checkGuard(null);
 
-		if (!isOpen) {
-			throw new IllegalStateException(
-					"Line cant be closed if it isnt open");
-		}
-
 		PulseAudioMixer parentMixer = PulseAudioMixer.getInstance();
 		parentMixer.removeTargetLine(this);
 
@@ -101,7 +105,7 @@
 		AudioPermission perm = new AudioPermission("record", null);
 		perm.checkGuard(null);
 
-		if (isOpen) {
+		if (isOpen()) {
 			throw new IllegalStateException("already open");
 		}
 		super.open(format, bufferSize);
@@ -142,8 +146,9 @@
 
 		/* check state and inputs */
 
-		if (!isOpen) {
-			throw new IllegalStateException("must call open() before read()");
+		if (!isOpen()) {
+			// A closed line can produce zero bytes of data.
+			return 0;
 		}
 
 		int frameSize = currentFormat.getFrameSize();
@@ -220,7 +225,7 @@
 		while (remainingLength != 0) {
 			synchronized (this) {
 
-				if (!isOpen || !isStarted) {
+				if (!isOpen() || !isStarted) {
 					return sizeRead;
 				}
 
@@ -287,57 +292,57 @@
 	@Override
 	public void drain() {
 
-		if (!isOpen) {
-			throw new IllegalStateException("must call open() before drain()");
+		// blocks when there is data on the line
+		// http://www.jsresources.org/faq_audio.html#stop_drain_tdl
+		while (true) {
+			synchronized (this) {
+				if (!isStarted || !isOpen()) {
+					break;
+				}
+			}
+			try {
+				//TODO: Is this the best length of sleep?
+				//Maybe in case this loop runs for a long time
+				//it would be good to switch to a longer
+				//sleep.  Like bump it up each iteration after
+				//the Nth iteration, up to a MAXSLEEP length.
+				Thread.sleep(100);
+			} catch (InterruptedException e) {
+				// do nothing
+			}
 		}
 
 		synchronized (this) {
 			drained = true;
 		}
 
-		// blocks when there is data on the line
-		// http://www.jsresources.org/faq_audio.html#stop_drain_tdl
-		while (true) {
-			synchronized (this) {
-				if (!isStarted || !isOpen) {
-					break;
-				}
-			}
-			try {
-				Thread.sleep(100);
-			} catch (InterruptedException e) {
-				// do nothing
-			}
-		}
-
 	}
 
 	@Override
 	public void flush() {
-		if (!isOpen) {
-			throw new IllegalStateException("Line must be open");
+		if (isOpen()) {
+
+			/* flush the buffer on pulseaudio's side */
+			Operation operation;
+			synchronized (eventLoop.threadLock) {
+				operation = stream.flush();
+			}
+			operation.waitForCompletion();
+			operation.releaseReference();
 		}
 
-		/* flush the buffer on pulseaudio's side */
-		Operation operation;
-		synchronized (eventLoop.threadLock) {
-			operation = stream.flush();
-		}
-		operation.waitForCompletion();
-		operation.releaseReference();
-
 		synchronized (this) {
 			flushed = true;
 			/* flush the partial fragment we stored */
 			fragmentBuffer = null;
 		}
-
 	}
 
 	@Override
 	public int available() {
-		if (!isOpen) {
-			throw new IllegalStateException("Line must be open");
+		if (!isOpen()) {
+			// a closed line has 0 bytes available.
+			return 0;
 		}
 
 		synchronized (eventLoop.threadLock) {
diff -r d1ad52447673 tapset/hotspot.stp.in
--- a/tapset/hotspot.stp.in	Wed Apr 14 12:21:30 2010 +0200
+++ b/tapset/hotspot.stp.in	Tue Jul 20 16:36:52 2010 +0200
@@ -120,7 +120,7 @@
   name = "object_alloc";
   thread_id = $arg1;
   class = user_string_n($arg2, $arg3);
-  size = $arg3;
+  size = $arg4;
   probestr = sprintf("%s(thread_id=%d,class='%s',size=0x%x)",
                      name, thread_id, class, size);
 }
